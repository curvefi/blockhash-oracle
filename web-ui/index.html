<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curve Blockhash Oracle Status</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: #0a0a0a;
            color: #fff;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px 20px;
            background: #1a1a1a;
            border-radius: 8px;
            border: 1px solid #333;
        }

        h1 {
            font-size: 24px;
            font-weight: 500;
        }

        button {
            background: #6366f1;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        button:hover { background: #5558e3; }
        button:disabled { background: #444; cursor: not-allowed; }

        .broadcast-btn {
            background: #10b981;
            padding: 6px 12px;
            font-size: 12px;
            margin-top: 8px;
        }

        .broadcast-btn:hover { background: #0ea968; }
        .broadcast-btn:disabled { background: #444; }

        .main-block {
            text-align: center;
            padding: 15px;
            background: #1a1a1a;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #333;
        }

        .main-block .number {
            font-size: 28px;
            font-weight: bold;
            color: #6366f1;
        }

        .main-block .contract-info {
            margin-top: 8px;
            font-size: 12px;
            color: #888;
        }

        .main-block .contract-info a {
            color: #6366f1;
            text-decoration: none;
        }

        .main-block .contract-info a:hover {
            text-decoration: underline;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 15px;
        }

        .chain {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 12px 15px;
            transition: transform 0.2s, border-color 0.2s;
        }

        .chain:hover {
            transform: translateY(-1px);
            border-color: #444;
        }

        .chain-name {
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 4px;
            text-transform: capitalize;
        }

        .contract-links {
            font-size: 11px;
            color: #666;
            margin-bottom: 8px;
        }

        .contract-links a {
            color: #888;
            text-decoration: none;
            margin-right: 8px;
        }

        .contract-links a:hover {
            color: #6366f1;
            text-decoration: underline;
        }

        .chain-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .action-buttons {
            display: flex;
            gap: 4px;
        }

        .action-btn {
            background: #10b981;
            padding: 4px 8px;
            font-size: 11px;
            border-radius: 4px;
            cursor: pointer;
            white-space: nowrap;
        }

        .action-btn:hover { background: #0ea968; }
        .action-btn:disabled { background: #444; }

        .submit-header-btn {
            background: #3b82f6;
        }

        .submit-header-btn:hover { background: #2563eb; }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            font-size: 13px;
            align-items: baseline;
        }

        .label { color: #888; font-size: 12px; }
        .value { font-family: monospace; font-size: 12px; text-align: right; }
        .time { color: #f59e0b; font-size: 11px; }
        .error { color: #ef4444; font-size: 12px; }
        .loading { color: #888; font-style: italic; font-size: 12px; }
        .outdated { color: #f59e0b; }

        .wallet-info {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 6px;
            font-size: 14px;
            display: none;
        }

        .wallet-info.connected { display: block; }

        .status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 20px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 6px;
            font-size: 14px;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: #1a1a1a;
            padding: 20px;
            border: 1px solid #333;
            border-radius: 8px;
            max-width: 500px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 18px;
        }

        .close {
            color: #888;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 20px;
        }

        .close:hover { color: #fff; }

        .peer-list {
            margin: 10px 0;
        }

        .peer-controls {
            display: flex;
            justify-content: flex-end;
            margin-bottom: 10px;
        }

        .flip-all-btn {
            background: #444;
            padding: 5px 12px;
            font-size: 12px;
            border-radius: 4px;
            cursor: pointer;
            border: none;
            color: white;
        }

        .flip-all-btn:hover { background: #555; }

        .peer-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            margin: 3px 0;
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 4px;
        }

        .peer-info {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }

        .peer-cost {
            color: #10b981;
            font-family: monospace;
            font-size: 12px;
        }

        .total-cost {
            margin-top: 15px;
            padding: 12px;
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            justify-content: flex-end;
        }

        .modal-buttons button {
            padding: 8px 16px;
            font-size: 13px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Blockhash Oracle Status</h1>
            <div style="display: flex; gap: 10px;">
                <button id="connect-btn" onclick="connectWallet()">Connect Wallet</button>
                <button id="refresh-btn" onclick="refreshData()">Refresh</button>
            </div>
        </header>

        <div class="main-block">
            <div>Ethereum Mainnet</div>
            <div class="number" id="main-block">-</div>
            <div class="contract-info" id="mainnet-contract-info"></div>
        </div>

        <div class="grid" id="chains-grid"></div>
    </div>

    <div class="status" id="status"></div>
    <div class="wallet-info" id="wallet-info"></div>

    <div class="modal" id="peerModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Select Broadcast Destinations</h2>
                <span class="close" onclick="closePeerModal()">&times;</span>
            </div>
            <div class="peer-list" id="peerList"></div>
            <div class="total-cost">
                <span>Total Cost:</span>
                <span id="totalCost" class="peer-cost">0 ETH</span>
            </div>
            <div class="modal-buttons">
                <button onclick="closePeerModal()">Cancel</button>
                <button id="confirmBroadcast" onclick="proceedWithBroadcast()">Confirm Broadcast</button>
            </div>
        </div>
    </div>

    <script>
        const DEPLOYMENT_URL = '../scripts/deployment/deployment_state.json';
        const CHAINS_URL = '../scripts/chain-parse/chains.json';
        const TIMEOUT = 10000;

        // Block explorer URLs
        const EXPLORER_URLS = {
            ethereum: 'https://etherscan.io/address/',
            arbitrum: 'https://arbiscan.io/address/',
            optimism: 'https://optimistic.etherscan.io/address/',
            polygon: 'https://polygonscan.com/address/',
            avalanche: 'https://snowscan.xyz/address/',
            bsc: 'https://bscscan.com/address/',
            fantom: 'https://ftmscan.com/address/',
            base: 'https://basescan.org/address/',
            gnosis: 'https://gnosisscan.io/address/',
            celo: 'https://celoscan.io/address/',
            moonbeam: 'https://moonscan.io/address/',
            xdc: 'https://xdcscan.com/address/',
            mantle: 'https://explorer.mantle.xyz/address/',
            fraxtal: 'https://fraxscan.com/address/',
            taiko: 'https://taikoscan.io/address/',
            sonic: 'https://sonicscan.org/address/',
            xlayer: 'https://www.oklink.com/x-layer/address/',
            tac: 'https://explorer.tac.build/address/',
            kava: 'https://kavascan.com/address/',
            aurora: 'https://explorer.aurora.dev/address/',
            hyperliquid: 'https://purrsec.com/explorer/address/',
            ink: 'https://explorer.inkonchain.com/address/',
            plume_phoenix: 'https://explorer.plumenetwork.xyz/address/',
            mp1: 'https://cornscan.io/address/'
        };

        const ORACLE_ABI = [
            "function last_confirmed_block_number() view returns (uint256)",
            "function block_header(uint256) view returns (bytes32, bytes32, bytes32, bytes32, uint256, uint256)",
            "function last_confirmed_header() view returns (bytes32, bytes32, bytes32, bytes32, uint256, uint256)"
        ];

        const RELAY_ABI = [
            "function quote_read_fee(uint128 gas, uint128 value) view returns (uint256)",
            "function quote_broadcast_fees(uint32[] eids, uint128 gas) view returns (uint256[])",
            "function request_block_hash(uint32[] receive_eids, uint256[] amounts, uint128 gas, uint128 read_gas) payable",
            "function peers(uint32) view returns (bytes32)",
            "function read_enabled() view returns (bool)",
            "function mainnet_eid() view returns (uint32)"
        ];

        const HEADER_VERIFIER_ABI = [
            "function submit_block_header(address oracle, bytes header) returns (bool)"
        ];

        let deployments = null;
        let chains = null;
        let lzMetadata = null;
        let mainBlock = 0;
        let provider = null;
        let signer = null;
        let walletConnected = false;
        const peerCache = {}; // Cache peer EIDs per chain
        let currentBroadcastData = null; // Store broadcast data for modal

        async function init() {
            try {
                setStatus('Loading...');

                // Load config files
                const [depResp, chainsResp, lzResp] = await Promise.all([
                    fetch(DEPLOYMENT_URL),
                    fetch(CHAINS_URL),
                    fetch('../scripts/deployment/lz_metadata.json')
                ]);

                const depData = await depResp.json();
                const chainsData = await chainsResp.json();
                lzMetadata = await lzResp.json();

                deployments = depData.deployments.mainnets || {};
                chains = chainsData.mainnets || {};

                await refreshData();
            } catch (error) {
                console.error('Init error:', error);
                setStatus('Failed to load', true);
            }
        }

        async function refreshData() {
            const btn = document.getElementById('refresh-btn');
            btn.disabled = true;
            setStatus('Updating...');

            try {
                // Clear and create all chain cards immediately
                const grid = document.getElementById('chains-grid');
                grid.innerHTML = '';

                const chainList = Object.entries(deployments)
                    .filter(([name, contracts]) => name !== 'ethereum' && contracts.BlockOracle)
                    .sort(([a], [b]) => a.localeCompare(b));

                // Create cards with loading state
                const cards = {};
                chainList.forEach(([chainName]) => {
                    const card = createChainCard(chainName, { loading: true });
                    cards[chainName] = card;
                    grid.appendChild(card);
                });

                // Get Ethereum block first (needed for age calculation)
                // Only fetch if we don't have it or it's been more than 1 minute
                const now = Date.now();
                if (chains.ethereum?.public && (!mainBlock || now - window.lastMainBlockFetch > 60000)) {
                    try {
                        const provider = new ethers.providers.JsonRpcProvider(chains.ethereum.public);
                        mainBlock = await withTimeout(provider.getBlockNumber(), TIMEOUT);
                        window.lastMainBlockFetch = now;
                        document.getElementById('main-block').textContent = mainBlock.toLocaleString();
                    } catch (error) {
                        document.getElementById('main-block').textContent = 'Error';
                    }
                }

                // Update MainnetBlockView address if available
                if (deployments.ethereum?.MainnetBlockView) {
                    const address = deployments.ethereum.MainnetBlockView;
                    const explorerUrl = getExplorerUrl('ethereum', address);
                    document.getElementById('mainnet-contract-info').innerHTML =
                        `View: <a href="${explorerUrl}" target="_blank">${formatAddress(address, true)}</a>`;
                }

                // Fetch all chain data in parallel and update cards as results come in
                chainList.forEach(async ([chainName, contracts]) => {
                    try {
                        const data = await fetchChainData(chainName, contracts);
                        updateChainCard(cards[chainName], chainName, data);
                    } catch (error) {
                        updateChainCard(cards[chainName], chainName, { error: 'Failed' });
                    }
                });

                setStatus(`Updated at ${new Date().toLocaleTimeString()}`);
            } catch (error) {
                console.error('Refresh error:', error);
                setStatus('Update failed', true);
            } finally {
                btn.disabled = false;
            }
        }

        async function fetchChainData(chainName, contracts) {
            const chainConfig = chains[chainName];
            if (!chainConfig?.public) {
                return { error: 'No RPC' };
            }

            try {
                const provider = new ethers.providers.JsonRpcProvider(chainConfig.public);
                const oracle = new ethers.Contract(contracts.BlockOracle, ORACLE_ABI, provider);

                const lastBlockNum = await withTimeout(oracle.last_confirmed_block_number(), TIMEOUT);
                const lastBlock = lastBlockNum.toNumber();

                let lastHeaderBlock = 0;
                let readEnabled = false;

                // Get last confirmed header directly from the contract
                try {
                    const lastHeader = await withTimeout(oracle.last_confirmed_header(), 5000);
                    // The function returns a tuple: (hash, parentHash, stateRoot, receiptsRoot, blockNumber, timestamp)
                    // Block number is at index 4
                    if (lastHeader && lastHeader[4]) {
                        lastHeaderBlock = lastHeader[4].toNumber();
                    }
                } catch (error) {
                    console.log(`Error getting last header for ${chainName}:`, error);
                    // Fallback: check if latest block has header
                    try {
                        const header = await withTimeout(oracle.block_header(lastBlock), 2000);
                        if (header[1] !== '0x0000000000000000000000000000000000000000000000000000000000000000') {
                            lastHeaderBlock = lastBlock;
                        }
                    } catch {}
                }

                // Check if read enabled
                if (contracts.LZBlockRelay) {
                    try {
                        const relay = new ethers.Contract(contracts.LZBlockRelay, RELAY_ABI, provider);
                        readEnabled = await withTimeout(relay.read_enabled(), 2000);
                    } catch {}
                }

                return { lastBlock, lastHeaderBlock, readEnabled };
            } catch (error) {
                if (error.message === 'Timeout') {
                    return { error: 'Timeout' };
                }
                return { error: 'Error' };
            }
        }

        function createChainCard(chainName, data) {
            const card = document.createElement('div');
            card.className = 'chain';
            card.id = `chain-${chainName}`;

            let blockHtml = '<span class="loading">Loading...</span>';
            let headerHtml = '<span class="loading">Loading...</span>';

            if (data && !data.loading) {
                if (data.error) {
                    blockHtml = `<span class="error">${data.error}</span>`;
                    headerHtml = `<span class="error">${data.error}</span>`;
                } else {
                    if (data.lastBlock) {
                        const blockAge = calculateAge(data.lastBlock);
                        blockHtml = `${data.lastBlock.toLocaleString()} <span class="time">(${blockAge})</span>`;
                    }

                    if (data.lastHeaderBlock) {
                        const headerAge = calculateAge(data.lastHeaderBlock);
                        const isOutdated = data.lastHeaderBlock < data.lastBlock;
                        headerHtml = `<span class="${isOutdated ? 'outdated' : ''}">${data.lastHeaderBlock.toLocaleString()}</span> <span class="time">(${headerAge})</span>`;
                    } else {
                        headerHtml = '<span class="error">None</span>';
                    }
                }
            }

            const showReadBroadcast = walletConnected && data && !data.loading && data.readEnabled;
            const showSubmitHeader = walletConnected && data && !data.loading && data.lastBlock > 0 &&
                                   data.lastHeaderBlock < data.lastBlock && deployments[chainName]?.HeaderVerifier;

            // Get contract links
            const contracts = deployments[chainName] || {};
            const contractLinks = [];
            if (contracts.BlockOracle) {
                const url = getExplorerUrl(chainName, contracts.BlockOracle);
                contractLinks.push(`<a href="${url}" target="_blank">Oracle</a>`);
            }
            if (contracts.LZBlockRelay) {
                const url = getExplorerUrl(chainName, contracts.LZBlockRelay);
                contractLinks.push(`<a href="${url}" target="_blank">LZRelay</a>`);
            }
            if (contracts.HeaderVerifier) {
                const url = getExplorerUrl(chainName, contracts.HeaderVerifier);
                contractLinks.push(`<a href="${url}" target="_blank">Verifier</a>`);
            }

            card.innerHTML = `
                <div class="chain-header">
                    <div>
                        <div class="chain-name">${chainName}</div>
                        <div class="contract-links">${contractLinks.join(' ')}</div>
                    </div>
                    <div class="action-buttons">
                        ${showReadBroadcast ?
                            `<button class="action-btn" id="broadcast-${chainName}" onclick="readAndBroadcast('${chainName}')">Broadcast</button>` :
                            ''}
                        ${showSubmitHeader ?
                            `<button class="action-btn submit-header-btn" id="submit-${chainName}" onclick="submitHeader('${chainName}')">Submit Header</button>` :
                            ''}
                    </div>
                </div>
                <div class="info-row">
                    <span class="label">Hash:</span>
                    <span class="value" id="${chainName}-block">${blockHtml}</span>
                </div>
                <div class="info-row">
                    <span class="label">Header:</span>
                    <span class="value" id="${chainName}-header">${headerHtml}</span>
                </div>
            `;

            return card;
        }

        function updateChainCard(card, chainName, data) {
            let blockHtml = '<span class="loading">Loading...</span>';
            let headerHtml = '<span class="loading">Loading...</span>';

            if (data.error) {
                blockHtml = `<span class="error">${data.error}</span>`;
                headerHtml = `<span class="error">${data.error}</span>`;
            } else {
                if (data.lastBlock) {
                    const blockAge = calculateAge(data.lastBlock);
                    blockHtml = `${data.lastBlock.toLocaleString()} <span class="time">(${blockAge})</span>`;
                }

                if (data.lastHeaderBlock) {
                    const headerAge = calculateAge(data.lastHeaderBlock);
                    const isOutdated = data.lastHeaderBlock < data.lastBlock;
                    headerHtml = `<span class="${isOutdated ? 'outdated' : ''}">${data.lastHeaderBlock.toLocaleString()}</span> <span class="time">(${headerAge})</span>`;
                } else {
                    headerHtml = '<span class="error">None</span>';
                }
            }

            document.getElementById(`${chainName}-block`).innerHTML = blockHtml;
            document.getElementById(`${chainName}-header`).innerHTML = headerHtml;

            // Update action buttons
            const actionButtons = card.querySelector('.action-buttons');
            if (actionButtons && !data.error) {
                const showReadBroadcast = walletConnected && data.readEnabled;
                const showSubmitHeader = walletConnected && data.lastBlock > 0 &&
                                       data.lastHeaderBlock < data.lastBlock && deployments[chainName]?.HeaderVerifier;

                let buttonsHtml = '';
                if (showReadBroadcast) {
                    buttonsHtml += `<button class="action-btn" id="broadcast-${chainName}" onclick="readAndBroadcast('${chainName}')">Broadcast</button>`;
                }
                if (showSubmitHeader) {
                    buttonsHtml += `<button class="action-btn submit-header-btn" id="submit-${chainName}" onclick="submitHeader('${chainName}')">Submit Header</button>`;
                }
                actionButtons.innerHTML = buttonsHtml;
            }
        }

        function calculateAge(blockNumber) {
            if (!mainBlock || blockNumber <= 0) return '';

            const blocksBehind = mainBlock - blockNumber;
            const seconds = blocksBehind * 12;

            if (seconds < 60) return `${Math.round(seconds)}s ago`;
            if (seconds < 3600) return `${Math.round(seconds / 60)}m ago`;
            if (seconds < 86400) return `${Math.round(seconds / 3600)}h ago`;

            const days = Math.floor(seconds / 86400);
            const hours = Math.round((seconds % 86400) / 3600);
            return `${days}d${hours}h ago`;
        }

        function withTimeout(promise, ms) {
            return Promise.race([
                promise,
                new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), ms))
            ]);
        }

        function getExplorerUrl(chainName, address) {
            const baseUrl = EXPLORER_URLS[chainName] || 'https://blockscan.com/address/';
            return baseUrl + address;
        }

        function formatAddress(address, extended = false) {
            if (extended) {
                return `${address.slice(0, 10)}...${address.slice(-5)}`;
            }
            return `${address.slice(0, 6)}...${address.slice(-4)}`;
        }

        function setStatus(text, isError = false) {
            const status = document.getElementById('status');
            status.textContent = text;
            status.style.color = isError ? '#ef4444' : '#888';
        }

        // Connect wallet
        async function connectWallet() {
            try {
                if (typeof window.ethereum === 'undefined') {
                    alert('Please install MetaMask');
                    return;
                }

                provider = new ethers.providers.Web3Provider(window.ethereum);
                await provider.send("eth_requestAccounts", []);
                signer = provider.getSigner();

                const address = await signer.getAddress();
                const network = await provider.getNetwork();

                walletConnected = true;
                document.getElementById('connect-btn').textContent = `${address.slice(0,6)}...${address.slice(-4)}`;
                document.getElementById('connect-btn').disabled = true;
                document.getElementById('wallet-info').textContent = `Chain ID: ${network.chainId}`;
                document.getElementById('wallet-info').classList.add('connected');

                // Refresh to show broadcast buttons
                await refreshData();
            } catch (error) {
                console.error('Wallet connection error:', error);
                alert('Failed to connect wallet');
            }
        }

        // Execute read->broadcast
        async function readAndBroadcast(chainName) {
            if (!walletConnected) {
                alert('Please connect wallet first');
                return;
            }

            try {
                const btn = document.getElementById(`broadcast-${chainName}`);
                btn.disabled = true;
                btn.textContent = 'Processing...';

                const contracts = deployments[chainName];
                const chainConfig = chains[chainName];
                const provider = new ethers.providers.JsonRpcProvider(chainConfig.public);
                const relay = new ethers.Contract(contracts.LZBlockRelay, RELAY_ABI, provider);

                // Get chain EID from LZ metadata
                const chainEid = getChainEid(chainName);
                if (!chainEid) {
                    alert('Chain EID not found');
                    btn.disabled = false;
                    btn.textContent = 'Read→Broadcast';
                    return;
                }

                // Get all peer EIDs
                const peerEids = await getPeerEids(chainName, relay);
                console.log(`Found ${peerEids.length} peers for ${chainName}:`, peerEids);

                if (peerEids.length === 0) {
                    alert('No peers configured');
                    btn.disabled = false;
                    btn.textContent = 'Broadcast';
                    return;
                }

                // Quote fees
                const receiveGas = 150000;
                console.log('Quoting broadcast fees for peers:', peerEids);
                const broadcastFees = await relay.quote_broadcast_fees(peerEids, receiveGas);

                // Get chain names for EIDs
                const peerData = peerEids.map((eid, index) => {
                    const chainName = getChainNameFromEid(eid);
                    const fee = broadcastFees[index];
                    const feeWithBuffer = ethers.BigNumber.from(fee).mul(101).div(100); // 1% buffer
                    return {
                        eid,
                        chainName: chainName || `EID ${eid}`,
                        fee: feeWithBuffer,
                        selected: true
                    };
                });

                // Sort by fee descending (most expensive first)
                peerData.sort((a, b) => {
                    if (b.fee.gt(a.fee)) return 1;
                    if (a.fee.gt(b.fee)) return -1;
                    return 0;
                });

                // Store data for modal
                currentBroadcastData = {
                    chainName,
                    contracts,
                    chainConfig,
                    relay,
                    peerData,
                    receiveGas,
                    BROADCAST_GAS: 5000000
                };

                // Show modal
                showPeerModal(peerData);
                btn.disabled = false;
                btn.textContent = 'Broadcast';

            } catch (error) {
                console.error('Broadcast error:', error);
                alert('Transaction failed: ' + (error.message || error));
                const btn = document.getElementById(`broadcast-${chainName}`);
                btn.disabled = false;
                btn.textContent = 'Broadcast';
            }
        }

        // Get chain EID from LZ metadata
        function getChainEid(chainName) {
            for (const [chainId, data] of Object.entries(lzMetadata)) {
                if (data.chainKey === chainName) {
                    const v2Deployment = data.deployments?.find(d => d.version === 2);
                    if (v2Deployment && v2Deployment.eid) {
                        return parseInt(v2Deployment.eid);
                    }
                }
            }
            return null;
        }

        // Get configured peer EIDs
        async function getPeerEids(chainName, relay) {
            // Check cache first
            const cacheKey = `${chainName}_peers`;
            const cached = peerCache[cacheKey];
            if (cached && Date.now() - cached.timestamp < 300000) { // 5 minute cache
                return cached.peers;
            }

            // Get mainnet EID first to exclude it
            let mainnetEid;
            try {
                mainnetEid = await relay.mainnet_eid();
            } catch {
                // If mainnet_eid is not available, use ethereum's EID
                mainnetEid = getChainEid('ethereum');
            }

            // Build list of potential peers
            const potentialPeers = [];
            for (const [peerChain, contracts] of Object.entries(deployments)) {
                if (peerChain === chainName || peerChain === 'ethereum' || !contracts.LZBlockRelay) continue;

                const peerEid = getChainEid(peerChain);
                if (!peerEid || peerEid === mainnetEid) continue;

                potentialPeers.push({ chain: peerChain, eid: peerEid });
            }

            // Check all peers in parallel
            const peerChecks = await Promise.allSettled(
                potentialPeers.map(async ({ chain, eid }) => {
                    try {
                        const peer = await relay.peers(eid);
                        if (peer !== '0x' + '00'.repeat(32)) {
                            return parseInt(eid);
                        }
                        return null;
                    } catch (error) {
                        console.log(`Error checking peer ${chain}:`, error);
                        return null;
                    }
                })
            );

            // Filter out nulls and failed promises
            const peers = peerChecks
                .filter(result => result.status === 'fulfilled' && result.value !== null)
                .map(result => result.value);

            // Cache the result
            peerCache[cacheKey] = { peers, timestamp: Date.now() };

            return peers;
        }

        // Submit block header
        async function submitHeader(chainName) {
            if (!walletConnected) {
                alert('Please connect wallet first');
                return;
            }

            try {
                const btn = document.getElementById(`submit-${chainName}`);
                btn.disabled = true;
                btn.textContent = 'Processing...';

                const contracts = deployments[chainName];
                const chainConfig = chains[chainName];
                const data = await fetchChainData(chainName, contracts);

                if (!data.lastBlock || data.lastBlock === 0) {
                    alert('No blocks to submit header for');
                    btn.disabled = false;
                    btn.textContent = 'Submit Header';
                    return;
                }

                // Get block data from ethereum mainnet
                const ethProvider = new ethers.providers.JsonRpcProvider(chains.ethereum.public);

                // Use raw JSON-RPC to get all block fields including stateRoot, receiptsRoot, etc.
                const blockHex = ethers.utils.hexValue(data.lastBlock);
                const block = await ethProvider.send('eth_getBlockByNumber', [blockHex, false]);

                if (!block) {
                    alert('Block not found on mainnet');
                    btn.disabled = false;
                    btn.textContent = 'Submit Header';
                    return;
                }

                // Encode block header using RLP
                const encodedHeader = encodeBlockHeader(block);

                // Switch to correct network
                const network = await signer.provider.getNetwork();
                if (network.chainId !== chainConfig.chain_id) {
                    try {
                        await window.ethereum.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: '0x' + chainConfig.chain_id.toString(16) }],
                        });
                        // Wait a bit for the switch to complete
                        await new Promise(resolve => setTimeout(resolve, 500));
                        // Update signer from Web3Provider after network switch
                        const web3Provider = new ethers.providers.Web3Provider(window.ethereum);
                        signer = web3Provider.getSigner();
                    } catch (error) {
                        if (error.code === 4902) {
                            alert(`Please add ${chainName} network to your wallet`);
                        } else {
                            alert(`Please switch to ${chainName} network`);
                        }
                        btn.disabled = false;
                        btn.textContent = 'Submit Header';
                        return;
                    }
                }

                // Submit header
                const verifier = new ethers.Contract(
                    contracts.HeaderVerifier,
                    HEADER_VERIFIER_ABI,
                    signer
                );

                const tx = await verifier.submit_block_header(
                    contracts.BlockOracle,
                    encodedHeader
                );

                btn.textContent = 'Confirming...';
                await tx.wait();

                btn.textContent = 'Success!';
                setTimeout(() => {
                    btn.textContent = 'Submit Header';
                    btn.disabled = false;
                    refreshData();
                }, 3000);

            } catch (error) {
                console.error('Submit header error:', error);
                alert('Submit header failed: ' + (error.message || error));
                const btn = document.getElementById(`submit-${chainName}`);
                btn.disabled = false;
                btn.textContent = 'Submit Header';
            }
        }

        // Encode block header for submission
        function encodeBlockHeader(block) {
            // Convert numeric value to proper format for RLP
            const toRlpNumber = (value) => {
                // Handle both numeric and hex string formats
                let bn;
                try {
                    if (typeof value === 'string' && value.startsWith('0x')) {
                        // Already hex string from RPC
                        bn = ethers.BigNumber.from(value);
                    } else {
                        // Regular number
                        bn = ethers.BigNumber.from(value || 0);
                    }
                } catch (e) {
                    console.error('Error parsing number:', value, e);
                    bn = ethers.BigNumber.from(0);
                }

                // RLP encoding: zero is encoded as empty byte array
                // In ethers.js, use "0x" which encodes to 0x80
                if (bn.isZero()) {
                    return "0x";
                }

                // For non-zero, return minimal hex representation
                return bn.toHexString();
            };

            // Build header fields array - must match the Python implementation exactly
            const fields = [
                block.parentHash,
                block.sha3Uncles || block.uncleHash || '0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347',
                block.miner,
                block.stateRoot,
                block.transactionsRoot || block.transactionRoot,
                block.receiptsRoot || block.receiptRoot,
                block.logsBloom,
                toRlpNumber(block.difficulty),
                toRlpNumber(block.number),
                toRlpNumber(block.gasLimit),
                toRlpNumber(block.gasUsed),
                toRlpNumber(block.timestamp),
                block.extraData || block.proofOfAuthorityData || '0x',
                block.mixHash || '0x0000000000000000000000000000000000000000000000000000000000000000',
                block.nonce || '0x0000000000000000'
            ];

            // Check for undefined values
            fields.forEach((field, index) => {
                if (field === undefined || field === null) {
                    console.error(`Field ${index} is undefined/null`, {
                        fieldNames: ['parentHash', 'sha3Uncles', 'miner', 'stateRoot', 'transactionsRoot',
                                   'receiptsRoot', 'logsBloom', 'difficulty', 'number', 'gasLimit',
                                   'gasUsed', 'timestamp', 'extraData', 'mixHash', 'nonce'],
                        blockData: block
                    });
                    throw new Error(`Field ${index} is undefined`);
                }
            });

            // Add EIP-1559 fields if present
            if (block.baseFeePerGas !== undefined && block.baseFeePerGas !== null) {
                fields.push(toRlpNumber(block.baseFeePerGas));
            }
            if (block.withdrawalsRoot && block.withdrawalsRoot !== '0x') {
                fields.push(block.withdrawalsRoot);
            }
            if (block.blobGasUsed !== undefined && block.blobGasUsed !== null) {
                fields.push(toRlpNumber(block.blobGasUsed));
            }
            if (block.excessBlobGas !== undefined && block.excessBlobGas !== null) {
                fields.push(toRlpNumber(block.excessBlobGas));
            }
            if (block.parentBeaconBlockRoot && block.parentBeaconBlockRoot !== '0x') {
                fields.push(block.parentBeaconBlockRoot);
            }
            // EIP-7685: requests hash (new in Pectra)
            if (block.requestsHash && block.requestsHash !== '0x') {
                fields.push(block.requestsHash);
            }

            // Debug log
            console.log('Block data:', block);
            console.log('Fields to encode:', fields);

            // Use ethers.js RLP encoding
            try {
                return ethers.utils.RLP.encode(fields);
            } catch (error) {
                console.error('RLP encoding error:', error);
                throw error;
            }
        }

        // Get chain name from EID
        function getChainNameFromEid(eid) {
            for (const [chainId, data] of Object.entries(lzMetadata)) {
                const v2Deployment = data.deployments?.find(d => d.version === 2);
                if (v2Deployment && parseInt(v2Deployment.eid) === eid) {
                    return data.chainKey;
                }
            }
            return null;
        }

        // Show peer selection modal
        function showPeerModal(peerData) {
            const modal = document.getElementById('peerModal');
            const peerList = document.getElementById('peerList');

            // Clear existing content
            peerList.innerHTML = '';

            // Add controls
            const controls = document.createElement('div');
            controls.className = 'peer-controls';
            controls.innerHTML = '<button class="flip-all-btn" onclick="flipAllPeers()">Flip All</button>';
            peerList.appendChild(controls);

            // Add peer items
            peerData.forEach((peer, index) => {
                const item = document.createElement('div');
                item.className = 'peer-item';
                item.innerHTML = `
                    <div class="peer-info">
                        <input type="checkbox" id="peer-${index}" checked onchange="updateTotalCost()">
                        <label for="peer-${index}">${peer.chainName}</label>
                    </div>
                    <span class="peer-cost">${ethers.utils.formatEther(peer.fee)} ETH</span>
                `;
                peerList.appendChild(item);
            });

            // Update total cost
            updateTotalCost();

            // Show modal
            modal.style.display = 'flex';
        }

        // Close modal
        function closePeerModal() {
            document.getElementById('peerModal').style.display = 'none';
            currentBroadcastData = null;
        }

        // Flip all checkboxes
        function flipAllPeers() {
            const checkboxes = document.querySelectorAll('#peerList input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = !checkbox.checked;
            });
            updateTotalCost();
        }

        // Update total cost based on selected peers
        function updateTotalCost() {
            if (!currentBroadcastData) return;

            let total = ethers.BigNumber.from(0);
            const checkboxes = document.querySelectorAll('#peerList input[type="checkbox"]');

            checkboxes.forEach((checkbox, index) => {
                if (checkbox.checked) {
                    total = total.add(currentBroadcastData.peerData[index].fee);
                }
            });

            // Calculate total fee including read fee
            const broadcastGasUint128 = Math.min(currentBroadcastData.BROADCAST_GAS, 2**128 - 1);
            const totalBroadcastFeeUint128 = total.gt(ethers.BigNumber.from(2).pow(128).sub(1))
                ? ethers.BigNumber.from(2).pow(128).sub(1)
                : total;

            currentBroadcastData.relay.quote_read_fee(
                broadcastGasUint128,
                totalBroadcastFeeUint128
            ).then(totalFee => {
                document.getElementById('totalCost').textContent = ethers.utils.formatEther(totalFee) + ' ETH';
            }).catch(console.error);
        }

        // Proceed with broadcast for selected peers
        async function proceedWithBroadcast() {
            if (!currentBroadcastData) return;

            const btn = document.getElementById('confirmBroadcast');
            btn.disabled = true;
            btn.textContent = 'Processing...';

            try {
                // Get selected peers
                const checkboxes = document.querySelectorAll('#peerList input[type="checkbox"]');
                const selectedPeers = [];
                const selectedFees = [];

                checkboxes.forEach((checkbox, index) => {
                    if (checkbox.checked) {
                        selectedPeers.push(currentBroadcastData.peerData[index].eid);
                        selectedFees.push(currentBroadcastData.peerData[index].fee);
                    }
                });

                if (selectedPeers.length === 0) {
                    alert('Please select at least one destination');
                    btn.disabled = false;
                    btn.textContent = 'Confirm Broadcast';
                    return;
                }

                const totalBroadcastFee = selectedFees.reduce((sum, fee) => sum.add(fee), ethers.BigNumber.from(0));

                // Ensure values fit in uint128
                const broadcastGasUint128 = Math.min(currentBroadcastData.BROADCAST_GAS, 2**128 - 1);
                const totalBroadcastFeeUint128 = totalBroadcastFee.gt(ethers.BigNumber.from(2).pow(128).sub(1))
                    ? ethers.BigNumber.from(2).pow(128).sub(1)
                    : totalBroadcastFee;

                const totalFee = await currentBroadcastData.relay.quote_read_fee(
                    broadcastGasUint128,
                    totalBroadcastFeeUint128
                );

                // Switch to correct network
                const network = await signer.provider.getNetwork();
                if (network.chainId !== currentBroadcastData.chainConfig.chain_id) {
                    try {
                        await window.ethereum.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: '0x' + currentBroadcastData.chainConfig.chain_id.toString(16) }],
                        });
                        await new Promise(resolve => setTimeout(resolve, 500));
                        const web3Provider = new ethers.providers.Web3Provider(window.ethereum);
                        signer = web3Provider.getSigner();
                    } catch (error) {
                        if (error.code === 4902) {
                            alert(`Please add ${currentBroadcastData.chainName} network to your wallet`);
                        } else {
                            alert(`Please switch to ${currentBroadcastData.chainName} network`);
                        }
                        btn.disabled = false;
                        btn.textContent = 'Confirm Broadcast';
                        return;
                    }
                }

                // Send transaction
                const relayWithSigner = new ethers.Contract(currentBroadcastData.contracts.LZBlockRelay, RELAY_ABI, signer);
                const tx = await relayWithSigner.request_block_hash(
                    selectedPeers,
                    selectedFees,
                    currentBroadcastData.receiveGas,
                    currentBroadcastData.BROADCAST_GAS,
                    { value: totalFee, gasLimit: 5000000 }
                );

                closePeerModal();
                setStatus('Transaction sent, waiting for confirmation...');

                await tx.wait();

                setStatus('Broadcast successful!');
                setTimeout(() => {
                    refreshData();
                }, 3000);

            } catch (error) {
                console.error('Broadcast error:', error);
                alert('Transaction failed: ' + (error.message || error));
                btn.disabled = false;
                btn.textContent = 'Confirm Broadcast';
            }
        }

        // Start on load
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
