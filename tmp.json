{"language": "Vyper", "sources": {"contracts/interfaces/IL1Block.vyi": {"content": "@view\n@external\ndef hash() -> bytes32:\n    ...\n\n@view\n@external\ndef number() -> uint64:\n    ...\n\n@view\n@external\ndef timestamp() -> uint64:\n    ...\n\n", "sha256sum": "2894e230bbd4115b4a4c47857f5bae9b63d9fe2e64a3460e4e1949594e2a9cba"}, "contracts/OPL1TestBlockStorage.vy": {"content": "# pragma version ~=0.4\n\n\"\"\"\n@title OP L1 Block Oracle with validation\n@dev Purpose is to be deployed on testnet and spammed to verify OP stack behavior in case of reorgs\n@notice Fetches and validates L1 block data against the oracle\n\"\"\"\n\nfrom interfaces import IL1Block\n\n################################################################\n#                           STORAGE                            #\n################################################################\n\nL1BLOCK_ORACLE: immutable(IL1Block)\n\nl1_blocks: public(HashMap[uint64, Block])\nlast_fetched_block: public(uint64)\n\nstruct Block:\n    block_hash: bytes32\n    block_timestamp: uint64\n\nevent BlockMismatch:\n    block_number: uint64\n    stored_hash: bytes32\n    oracle_hash: bytes32\n    stored_timestamp: uint64\n    oracle_timestamp: uint64\n\n################################################################\n#                         CONSTRUCTOR                          #\n################################################################\n\n@deploy\ndef __init__(l1block_precompile_address: address):\n    L1BLOCK_ORACLE = IL1Block(l1block_precompile_address)\n    self._fetch_latest_block()\n\n################################################################\n#                        INTERNAL FUNCTIONS                    #\n################################################################\n\n@internal\ndef _fetch_latest_block():\n    block_number: uint64 = staticcall L1BLOCK_ORACLE.number()\n    oracle_hash: bytes32 = staticcall L1BLOCK_ORACLE.hash()\n    oracle_timestamp: uint64 = staticcall L1BLOCK_ORACLE.timestamp()\n\n    if self._is_fetched(block_number):\n        stored: Block = self.l1_blocks[block_number]\n        if stored.block_hash != oracle_hash or stored.block_timestamp != oracle_timestamp:\n            log BlockMismatch(\n                block_number,\n                stored.block_hash,\n                oracle_hash,\n                stored.block_timestamp,\n                oracle_timestamp\n            )\n            # We keep the first seen values and don't update\n    else:\n        # Store new block data\n        self.l1_blocks[block_number] = Block(\n            block_hash=oracle_hash,\n            block_timestamp=oracle_timestamp\n        )\n        self.last_fetched_block = block_number\n\n@internal\ndef _is_fetched(block_number: uint64) -> bool:\n    return self.l1_blocks[block_number].block_hash != empty(bytes32)\n\n################################################################\n#                      EXTERNAL FUNCTIONS                      #\n################################################################\n\n@external\ndef fetch_latest_block():\n    self._fetch_latest_block()\n\n@external\ndef get_block_hash(block_number: uint64) -> bytes32:\n    block_hash: bytes32 = self.l1_blocks[block_number].block_hash\n    assert block_hash != empty(bytes32), \"Block not fetched\"\n    return block_hash\n\n@external\ndef get_block_timestamp(block_number: uint64) -> uint64:\n    block_timestamp: uint64 = self.l1_blocks[block_number].block_timestamp\n    assert block_timestamp != 0, \"Block not fetched\"\n    return block_timestamp\n\n@external \n@view\ndef peek_l1block_number() -> uint64:\n    return staticcall L1BLOCK_ORACLE.number()", "sha256sum": "acf0d473b0bdc35444e7ba87817f25750df584d51a70f201ba248bdfad7e8e79"}}, "settings": {"outputSelection": {"contracts/OPL1TestBlockStorage.vy": ["*"]}, "search_paths": ["."]}, "compiler_version": "v0.4.0+commit.e9db8d9", "integrity": "b5c64bfee36597d8d83eaf296a61b11b0d80225ce94f1aafdbeae86aa07385d7"}
