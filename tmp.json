{"language": "Vyper", "sources": {"contracts/messengers/LayerZeroV2.vy": {"content": "# pragma version ~=0.4\n\n\"\"\"\n@title Layer Zero V2 Vyper Module\n\n@notice Base contract for LayerZero cross-chain messaging. Provides core\nfunctionality for lzSend messages and lzRead.\n\n@dev Core functionality is organized around:\n1. Option building - prepare_message_options and prepare_read_options for different message types\n2. Read request preparation - prepare_read_message for encoding read requests from calldata\n3. Unified sending - single _send_message function that works with both message types\n\n@license Copyright (c) Curve.Fi, 2025 - all rights reserved\n\n@author curve.fi\n\n@custom:security security@curve.fi\n\n\"\"\"\n\n################################################################\n#                         INTERFACES                           #\n################################################################\n\ninterface ILayerZeroEndpointV2:\n    def quote(_params: MessagingParams, _sender: address) -> MessagingFee: view\n    def send(_params: MessagingParams, _refundAddress: address) -> (\n        bytes32, uint64, uint256, uint256\n    ): payable\n    def setDelegate(_delegate: address): nonpayable\n    def setSendLibrary(_oapp: address, _eid: uint32, _newLib: address): nonpayable\n    def setReceiveLibrary(\n        _oapp: address, _eid: uint32, _newLib: address, _gracePeriod: uint256\n    ): nonpayable\n    def setConfig(_oapp: address, _lib: address, _params: DynArray[SetConfigParam, 1]): nonpayable\n    def eid() -> uint32: view\n\n################################################################\n#                           CONSTANTS                          #\n################################################################\n\n# Message size limits\nLZ_MESSAGE_SIZE_CAP: public(constant(uint256)) = 512\nLZ_READ_CALLDATA_SIZE: public(constant(uint256)) = 256\n\n# LayerZero protocol constants\nTYPE_3: constant(bytes2) = 0x0003  # uint16\nWORKER_ID: constant(bytes1) = 0x01  # uint8\nOPTIONS_HEADER: constant(bytes3) = 0x000301  # concat(TYPE_3, WORKER_ID)\n\nOPTION_TYPE_LZRECEIVE: constant(bytes1) = 0x01\nOPTION_TYPE_NATIVE_DROP: constant(bytes1) = 0x02\nOPTION_TYPE_LZREAD: constant(bytes1) = 0x05\nREAD_CHANNEL_THRESHOLD: constant(uint32) = 4294965694  # max(uint32)-1600\n\n# Read codec constants\nCMD_VERSION: constant(uint16) = 1\nREQUEST_VERSION: constant(uint8) = 1\nRESOLVER_TYPE: constant(uint16) = 1\n\n# Options size cap\nLZ_OPTION_SIZE: constant(uint256) = 64\n\n#\nMAX_DVNS: constant(uint8) = 10\nMAX_PEERS: constant(uint256) = 128\n\n\n################################################################\n#                           STORAGE                            #\n################################################################\n\nLZ_ENDPOINT: public(ILayerZeroEndpointV2)  # Not immutable for init fcn\nEID: public(uint32)\nLZ_PEERS: public(HashMap[uint32, address])\nLZ_READ_CHANNEL: public(uint32)\nLZ_DELEGATE: public(address)\ndefault_gas_limit: public(uint256)\nis_initialized: public(bool)\n\n# Track configured peer EIDs\nconfigured_eids: DynArray[uint32, MAX_PEERS]\n\n\n################################################################\n#                           STRUCTS                            #\n################################################################\n\nstruct MessagingParams:\n    dstEid: uint32\n    receiver: bytes32  # Low level format for LZ\n    message: Bytes[LZ_MESSAGE_SIZE_CAP]\n    options: Bytes[LZ_OPTION_SIZE]\n    payInLzToken: bool\n\n\nstruct MessagingFee:\n    nativeFee: uint256\n    lzTokenFee: uint256\n\n\nstruct Origin:\n    srcEid: uint32\n    sender: bytes32\n    nonce: uint64\n\n\nstruct EVMCallRequestV1:\n    appRequestLabel: uint16\n    targetEid: uint32\n    isBlockNum: bool\n    blockNumOrTimestamp: uint64\n    confirmations: uint16\n    to: address\n    callData: Bytes[LZ_READ_CALLDATA_SIZE]\n\n\nstruct SetConfigParam:\n    eid: uint32\n    configType: uint32\n    config: Bytes[1024]\n\n\nstruct ULNConfig:\n    confirmations: uint64\n    required_dvn_count: uint8\n    optional_dvn_count: uint8\n    optional_dvn_threshold: uint8\n    required_dvns: DynArray[address, MAX_DVNS]  # Max 10 DVNs\n    optional_dvns: DynArray[address, MAX_DVNS]  # Max 10 DVNs\n\n\nstruct ULNReadConfig:\n    executor: address\n    required_dvn_count: uint8\n    optional_dvn_count: uint8\n    optional_dvn_threshold: uint8\n    required_dvns: DynArray[address, MAX_DVNS]  # Max 10 DVNs\n    optional_dvns: DynArray[address, MAX_DVNS]  # Max 10 DVNs\n\n\n################################################################\n#                         CONSTRUCTOR                          #\n################################################################\n\n@deploy\ndef __init__():\n    \"\"\"\n    @notice Empty constructor for deterministic deployment\n    \"\"\"\n    pass\n\n\n################################################################\n#                   SETTERS [GUARD THESE!]                     #\n################################################################\n# Note: External wrappers to these internal functions must enforce\n# proper authorization.\n# Exposing these functions without ownership check will lead to anyone\n# being able to bridge any message/command (=loss of funds).\n\n@internal\ndef _initialize(\n    _endpoint: address,\n    _default_gas_limit: uint256,\n    _read_channel: uint32,\n    _peer_eids: DynArray[uint32, MAX_PEERS],\n    _peers: DynArray[address, MAX_PEERS],\n):\n    \"\"\"\n    @notice Configure the contract with core settings\n    @param _endpoint LayerZero endpoint address\n    @param _default_gas_limit Default gas limit for messages\n    @param _read_channel LZ Read channel ID\n    @dev can only be called once\n    \"\"\"\n    assert _endpoint != empty(address), \"Invalid endpoint\"\n    assert len(_peer_eids) == len(_peers), \"Invalid peer arrays\"\n    assert not self.is_initialized, \"Already initialized\"\n\n    self.LZ_ENDPOINT = ILayerZeroEndpointV2(_endpoint)\n    self.EID = staticcall self.LZ_ENDPOINT.eid()\n    self._set_default_gas_limit(_default_gas_limit)\n    self._set_lz_read_channel(_read_channel)\n    for i: uint256 in range(0, len(_peer_eids), bound=MAX_PEERS):\n        self._set_peer(_peer_eids[i], _peers[i])\n    self.is_initialized = True\n\n\n@internal\ndef _set_peer(_srcEid: uint32, _peer: address):\n    \"\"\"@notice Set trusted peer for chain ID\"\"\"\n\n    old_peer: address = self.LZ_PEERS[_srcEid]\n    self.LZ_PEERS[_srcEid] = _peer\n\n    # Update configured_eids list\n    if old_peer == empty(address) and _peer != empty(address):\n        # New peer being added\n        self.configured_eids.append(_srcEid)\n    elif old_peer != empty(address) and _peer == empty(address):\n        # Peer being removed\n        updated_eids: DynArray[uint32, MAX_PEERS] = []\n        for eid: uint32 in self.configured_eids:\n            if eid != _srcEid:\n                updated_eids.append(eid)\n        self.configured_eids = updated_eids\n\n\n@internal\ndef _set_default_gas_limit(_gas_limit: uint256):\n    \"\"\"@notice Update default gas limit\"\"\"\n\n    self.default_gas_limit = _gas_limit\n\n\n@internal\ndef _set_lz_read_channel(_read_channel: uint32):\n    \"\"\"@notice Set read channel ID\"\"\"\n\n    self.LZ_READ_CHANNEL = _read_channel\n\n\n@internal\ndef _set_delegate(_delegate: address):\n    \"\"\"@notice Set delegate that can change any LZ setting\"\"\"\n\n    extcall self.LZ_ENDPOINT.setDelegate(_delegate)\n    self.LZ_DELEGATE = _delegate\n\n\n@internal\ndef _set_send_lib(_eid: uint32, _lib: address):\n    \"\"\"@notice Set new send library for send requests\"\"\"\n\n    extcall self.LZ_ENDPOINT.setSendLibrary(self, _eid, _lib)\n\n\n@internal\ndef _set_receive_lib(_eid: uint32, _lib: address):\n    \"\"\"@notice Set new receive library for receive requests\"\"\"\n\n    extcall self.LZ_ENDPOINT.setReceiveLibrary(self, _eid, _lib, 0)\n    # 0 is for grace period, not used in this contract\n\n\n@internal\ndef _set_uln_config(\n    _eid: uint32,\n    _oapp: address,\n    _lib: address,\n    _config_type: uint32,\n    _confirmations: uint64,\n    _required_dvns: DynArray[address, MAX_DVNS],\n    _optional_dvns: DynArray[address, MAX_DVNS],\n    _optional_dvn_threshold: uint8,\n):\n    \"\"\"\n    @notice Set ULN config for remote endpoint\n    @dev Arrays must be sorted in ascending order with no duplicates, or lz will fail\n    \"\"\"\n\n    config_param: SetConfigParam = self._prepare_uln_config(\n        _eid, _config_type, _confirmations, _required_dvns, _optional_dvns, _optional_dvn_threshold\n    )\n\n    # Call endpoint to set config\n    extcall self.LZ_ENDPOINT.setConfig(_oapp, _lib, [config_param])\n\n\n################################################################\n#                      OPTION PREPARATION                      #\n################################################################\n\n@internal\n@pure\ndef _prepare_options(_gas: uint256, _value: uint256, _data_size: uint32) -> Bytes[LZ_OPTION_SIZE]:\n    \"\"\"\n    @notice Build options for message sending\n    @param _gas Gas limit for execution on destination\n    @param _value Optional native value\n    @param _data_size If nonzero, indicates a read request; otherwise regular message\n    \"\"\"\n    gas_bytes: Bytes[16] = concat(convert(convert(_gas, uint128), bytes16), b\"\")  # gas\n    value_bytes: Bytes[16] = concat(convert(convert(_value, uint128), bytes16), b\"\")  # value\n    data_size_bytes: Bytes[4] = concat(convert(_data_size, bytes4), b\"\")  # data size\n\n    full_option: Bytes[36] = empty(Bytes[36])\n    if _data_size > 0 and _value > 0:\n        # read request with value\n        full_option = concat(gas_bytes, data_size_bytes, value_bytes)\n    elif _data_size > 0:\n        # read request without value\n        full_option = concat(gas_bytes, data_size_bytes)\n    elif _value > 0:\n        # regular message with value\n        full_option = concat(gas_bytes, value_bytes)\n    else:\n        # regular message without value\n        full_option = gas_bytes\n\n    return concat(\n        OPTIONS_HEADER,\n        convert(convert(len(full_option) + 1, uint16), bytes2),  # length (option) + 1 [type]\n        OPTION_TYPE_LZREAD if _data_size > 0 else OPTION_TYPE_LZRECEIVE,\n        full_option,\n    )\n\n\n@internal\n@pure\ndef _prepare_uln_config(\n    _eid: uint32,\n    _config_type: uint32,\n    _confirmations: uint64,\n    _required_dvns: DynArray[address, 10],\n    _optional_dvns: DynArray[address, 10],\n    _optional_dvn_threshold: uint8,\n) -> SetConfigParam:\n    \"\"\"\n    @notice Prepare ULN config from arrays, automatically calculating counts\n    \"\"\"\n\n    required_count: uint8 = convert(len(_required_dvns), uint8)\n    optional_count: uint8 = convert(len(_optional_dvns), uint8)\n\n    assert _optional_dvn_threshold <= optional_count, \"Invalid DVN threshold\"\n\n    if _eid > READ_CHANNEL_THRESHOLD:  # read config\n        uln_config: ULNReadConfig = ULNReadConfig(\n            executor=empty(address),  # default executor\n            required_dvn_count=required_count,\n            optional_dvn_count=optional_count,\n            optional_dvn_threshold=_optional_dvn_threshold,\n            required_dvns=_required_dvns,\n            optional_dvns=_optional_dvns,\n        )\n        return SetConfigParam(eid=_eid, configType=_config_type, config=abi_encode(uln_config))\n    else:\n        uln_config: ULNConfig = ULNConfig(\n            confirmations=_confirmations,\n            required_dvn_count=required_count,\n            optional_dvn_count=optional_count,\n            optional_dvn_threshold=_optional_dvn_threshold,\n            required_dvns=_required_dvns,\n            optional_dvns=_optional_dvns,\n        )\n        return SetConfigParam(eid=_eid, configType=_config_type, config=abi_encode(uln_config))\n\n\n################################################################\n#                    READ MESSAGE ENCODING                     #\n################################################################\n\n@view\n@internal\ndef _is_read_response(_origin: Origin) -> bool:\n    return _origin.srcEid > READ_CHANNEL_THRESHOLD\n\n\n@internal\n@pure\ndef _encode_read_request(_request: EVMCallRequestV1) -> Bytes[LZ_MESSAGE_SIZE_CAP]:\n    \"\"\"\n    @notice Encode read request following ReadCmdCodecV1 format\n    \"\"\"\n\n    # Calculate request size (35 bytes of fixed fields + calldata)\n    request_size: uint16 = convert(len(_request.callData) + 35, uint16)\n\n    # First part of headers (matches ReadCmdCodecV1.sol:183)\n    encoded_headers_1: Bytes[6] = concat(\n        convert(CMD_VERSION, bytes2),  # version = 1\n        convert(0, bytes2),  # appCmdLabel = 0\n        convert(1, bytes2),  # requests length = 1\n    )\n\n    # Complete headers (matches ReadCmdCodecV1.sol:195)\n    encoded_headers_2: Bytes[13] = concat(\n        encoded_headers_1,  # 6 bytes\n        convert(REQUEST_VERSION, bytes1),  # version = 1\n        convert(_request.appRequestLabel, bytes2),  # request label\n        convert(RESOLVER_TYPE, bytes2),  # resolver type = 1\n        convert(request_size, bytes2),  # payload size\n    )\n\n    # Add request fields (matches ReadCmdCodecV1.sol:204)\n    return concat(\n        encoded_headers_2,  # 13 bytes\n        convert(_request.targetEid, bytes4),  # +4=17\n        convert(_request.isBlockNum, bytes1),  # +1=18\n        convert(_request.blockNumOrTimestamp, bytes8),  # +8=26\n        convert(_request.confirmations, bytes2),  # +2=28\n        convert(_request.to, bytes20),  # +20=48 (35 w/o headers)\n        _request.callData,  # +variable\n    )\n\n\n################################################################\n#                       CORE FUNCTIONS                         #\n################################################################\n\n@internal\n@view\ndef _prepare_messaging_params(\n    _dstEid: uint32,\n    _receiver: bytes32,\n    _message: Bytes[LZ_MESSAGE_SIZE_CAP],\n    _gas_limit: uint256,\n    _value: uint256 = 0,\n    _data_size: uint32 = 0,  # Zero indicates regular message, non-zero for read\n) -> MessagingParams:\n    \"\"\"\n    @notice Prepare parameters for LayerZero endpoint interactions\n    @dev This function unifies parameter preparation for both sending and quoting.\n    The same structure is needed in both cases since they interact with the same\n    endpoint interface. The data_size parameter determines if we're preparing\n    for a regular message (data_size=0) or a read request (data_size>0).\n\n    @param _dstEid Destination chain ID\n    @param _receiver Target address (empty for reads)\n    @param _message Message payload or encoded read request\n    @param _gas_limit Gas limit for execution\n    @param _data_size For read requests, expected response size\n    @return Prepared parameters for endpoint interaction\n    \"\"\"\n\n    gas: uint256 = _gas_limit if _gas_limit != 0 else self.default_gas_limit\n    options: Bytes[LZ_OPTION_SIZE] = self._prepare_options(gas, _value, _data_size)\n    return MessagingParams(\n        dstEid=_dstEid, receiver=_receiver, message=_message, options=options, payInLzToken=False\n    )\n\n\n@view\n@internal\ndef _prepare_read_message_bytes(\n    _dst_eid: uint32,\n    _target: address,\n    _calldata: Bytes[LZ_READ_CALLDATA_SIZE],\n    _isBlockNum: bool = False,  # Use timestamp by default\n    _blockNumOrTimestamp: uint64 = 0,  # Uses latest ts (or block!) if 0\n    _confirmations: uint16 = 15,\n) -> Bytes[LZ_MESSAGE_SIZE_CAP]:\n    \"\"\"\n    @notice Helper to prepare read request message from basic parameters\n    @dev Constructs EVMCallRequestV1, encodes it into message and returns\n    all parameters needed for quote or send. Uses current block timestamp\n    and default confirmations.\n\n    @param _dst_eid Target chain ID to read from\n    @param _target Contract address to read from\n    @param _calldata Function call data\n    @return Parameters for quoting/sending:\n        - destination chain ID (will be READ_CHANNEL)\n        - receiver (empty for reads)\n        - encoded message\n    \"\"\"\n\n    # Process block number or timestamp\n    blockNumOrTimestamp: uint64 = _blockNumOrTimestamp\n    if blockNumOrTimestamp == 0:\n        if _isBlockNum:\n            blockNumOrTimestamp = convert(block.number, uint64)\n        else:\n            blockNumOrTimestamp = convert(block.timestamp, uint64)\n\n    # Create read request with sensible defaults\n    request: EVMCallRequestV1 = EVMCallRequestV1(\n        appRequestLabel=1,\n        targetEid=_dst_eid,\n        isBlockNum=_isBlockNum,\n        blockNumOrTimestamp=blockNumOrTimestamp,\n        confirmations=_confirmations,  # Default confirmations\n        to=_target,\n        callData=_calldata,\n    )\n\n    # Encode request into message\n    message: Bytes[LZ_MESSAGE_SIZE_CAP] = self._encode_read_request(request)\n\n    return message\n\n\n@view\n@internal\ndef _quote_lz_fee(\n    _dstEid: uint32,\n    _receiver: address,\n    _message: Bytes[LZ_MESSAGE_SIZE_CAP],\n    _gas_limit: uint256 = 0,\n    _value: uint256 = 0,\n    _data_size: uint32 = 0,\n) -> uint256:\n    \"\"\"@notice Quote fee using prepared parameters\"\"\"\n\n    params: MessagingParams = self._prepare_messaging_params(\n        _dstEid, convert(_receiver, bytes32), _message, _gas_limit, _value, _data_size\n    )\n    fees: MessagingFee = staticcall self.LZ_ENDPOINT.quote(params, self)\n    return fees.nativeFee\n\n\n@payable\n@internal\ndef _send_message(\n    _dstEid: uint32,\n    _receiver: bytes32,\n    _message: Bytes[LZ_MESSAGE_SIZE_CAP],\n    _gas_limit: uint256 = 0,\n    _lz_receive_value: uint256 = 0,\n    _data_size: uint32 = 0,\n    _request_msg_value: uint256 = 0,\n    _refund_address: address = msg.sender,\n    _perform_fee_check: bool = False,\n):\n    \"\"\"@notice Send message using prepared parameters\n    @dev This function is used to send both regular messages and read requests\n    @param _dstEid Destination chain ID\n    @param _receiver Target address\n    @param _message Message payload or encoded read request\n    @param _gas_limit Gas limit for execution\n    @param _lz_receive_value Value to send in lzReceive\n    @param _data_size For read requests, expected response size\n    @param _request_msg_value Value to send in request message (msg.value or less)\n    @param _refund_address Address to refund any excess msg.value\n    @param _perform_fee_check Whether to perform fee check\n    \"\"\"\n\n    params: MessagingParams = self._prepare_messaging_params(\n        _dstEid, _receiver, _message, _gas_limit, _lz_receive_value, _data_size\n    )\n\n    # optional logic to call send as part of larger transaction\n    message_value: uint256 = 0\n    if _request_msg_value == 0:\n        message_value = msg.value\n    else:\n        message_value = _request_msg_value\n\n    if _perform_fee_check:\n        fees: MessagingFee = staticcall self.LZ_ENDPOINT.quote(params, self)\n        assert message_value >= fees.nativeFee, \"Not enough fees\"\n\n    extcall self.LZ_ENDPOINT.send(\n        params, _refund_address, value=message_value\n    )\n\n\n@payable\n@internal\ndef _lz_receive(\n    _origin: Origin,\n    _guid: bytes32,\n    _message: Bytes[LZ_MESSAGE_SIZE_CAP],\n    _executor: address,\n    _extraData: Bytes[64],\n) -> bool:\n    \"\"\"\n    @notice Base security checks for received messages\n    @dev Must be called by importing contract's lzReceive\n    \"\"\"\n\n    assert msg.sender == self.LZ_ENDPOINT.address, \"Not LZ endpoint\"\n    assert self.LZ_PEERS[_origin.srcEid] != empty(address), \"LZ Peer not set\"\n    assert (\n        convert(_origin.sender, address) == self.LZ_PEERS[_origin.srcEid]\n    ), \"Invalid LZ message source!\"\n    return True\n\n\n################################################################\n#                     EXTERNAL FUNCTIONS                       #\n################################################################\n\n@view\n@external\ndef get_configured_eids() -> DynArray[uint32, MAX_PEERS]:\n    \"\"\"\n    @notice Get list of all configured peer EIDs\n    @return List of EIDs that have non-zero peer addresses\n    \"\"\"\n    return self.configured_eids\n\n\n@view\n@external\ndef nextNonce(_srcEid: uint32, _sender: bytes32) -> uint64:\n    \"\"\"@notice Protocol endpoint for nonce tracking\"\"\"\n\n    return 0\n\n\n@view\n@external\ndef allowInitializePath(_origin: Origin) -> bool:\n    \"\"\"@notice Protocol endpoint for path initialization\"\"\"\n\n    return True\n", "sha256sum": "fa6cf3783eb89d5dbfb07fea3bb673722694fa11cb712953da30dab85cb0708c"}, ".venv/lib/python3.12/site-packages/snekmate/auth/ownable.vy": {"content": "# pragma version ~=0.4.0\n\"\"\"\n@title Owner-Based Access Control Functions\n@custom:contract-name ownable\n@license GNU Affero General Public License v3.0 only\n@author pcaversaccio\n@notice These functions can be used to implement a basic access\n        control mechanism, where there is an account (an owner)\n        that can be granted exclusive access to specific functions.\n        By default, the owner account will be the one that deploys\n        the contract. This can later be changed with `transfer_ownership`.\n        An exemplary integration can be found in the ERC-20 implementation here:\n        https://github.com/pcaversaccio/snekmate/blob/main/src/snekmate/tokens/erc20.vy.\n        The implementation is inspired by OpenZeppelin's implementation here:\n        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol.\n\"\"\"\n\n\n# @dev Returns the address of the current owner.\n# @notice If you declare a variable as `public`,\n# Vyper automatically generates an `external`\n# getter function for the variable.\nowner: public(address)\n\n\n# @dev Emitted when the ownership is transferred\n# from `previous_owner` to `new_owner`.\nevent OwnershipTransferred:\n    previous_owner: indexed(address)\n    new_owner: indexed(address)\n\n\n@deploy\n@payable\ndef __init__():\n    \"\"\"\n    @dev To omit the opcodes for checking the `msg.value`\n         in the creation-time EVM bytecode, the constructor\n         is declared as `payable`.\n    @notice The `owner` role will be assigned to\n            the `msg.sender`.\n    \"\"\"\n    self._transfer_ownership(msg.sender)\n\n\n@external\ndef transfer_ownership(new_owner: address):\n    \"\"\"\n    @dev Transfers the ownership of the contract\n         to a new account `new_owner`.\n    @notice Note that this function can only be\n            called by the current `owner`. Also,\n            the `new_owner` cannot be the zero address.\n    @param new_owner The 20-byte address of the new owner.\n    \"\"\"\n    self._check_owner()\n    assert new_owner != empty(address), \"ownable: new owner is the zero address\"\n    self._transfer_ownership(new_owner)\n\n\n@external\ndef renounce_ownership():\n    \"\"\"\n    @dev Leaves the contract without an owner.\n    @notice Renouncing ownership will leave the\n            contract without an owner, thereby\n            removing any functionality that is\n            only available to the owner.\n    \"\"\"\n    self._check_owner()\n    self._transfer_ownership(empty(address))\n\n\n@internal\ndef _check_owner():\n    \"\"\"\n    @dev Throws if the sender is not the owner.\n    \"\"\"\n    assert msg.sender == self.owner, \"ownable: caller is not the owner\"\n\n\n@internal\ndef _transfer_ownership(new_owner: address):\n    \"\"\"\n    @dev Transfers the ownership of the contract\n         to a new account `new_owner`.\n    @notice This is an `internal` function without\n            access restriction.\n    @param new_owner The 20-byte address of the new owner.\n    \"\"\"\n    old_owner: address = self.owner\n    self.owner = new_owner\n    log OwnershipTransferred(old_owner, new_owner)\n", "sha256sum": "88ae32cf8b3e4a332d6518256019193419150e7ff716dd006a8d471550c329fc"}, "contracts/messengers/LZBlockRelay.vy": {"content": "# pragma version ~=0.4\n\n\"\"\"\n@title Example LayerZero Messenger\n\n@notice Example implementation of LZ Base module for simple messaging between\nchains. Allows sending and receiving string messages across chains using LayerZero\nprotocol. Includes ownership control for secure peer management and configuration.\n\n@license Copyright (c) Curve.Fi, 2025 - all rights reserved\n\n@author curve.fi\n\n@custom:security security@curve.fi\n\n\"\"\"\n\n\n################################################################\n#                           INTERFACES                         #\n################################################################\n\ninterface IBlockOracle:\n    def commit_block(block_number: uint256, block_hash: bytes32) -> bool: nonpayable\n    def last_confirmed_block_number() -> uint256: view\n    def block_hash(block_number: uint256) -> bytes32: view\n\n\n################################################################\n#                            MODULES                           #\n################################################################\n\n# Import LayerZero module for cross-chain messaging\nimport LayerZeroV2 as lz\ninitializes: lz\nexports: (\n    lz.LZ_ENDPOINT,\n    lz.LZ_PEERS,\n    lz.LZ_DELEGATE,\n    lz.LZ_READ_CHANNEL,\n    lz.default_gas_limit,\n    lz.nextNonce,\n    lz.allowInitializePath,\n    lz.get_configured_eids,\n)\n\n# Import ownership management\nfrom snekmate.auth import ownable\n\ninitializes: ownable\nexports: (\n    ownable.owner,\n    ownable.transfer_ownership,\n    ownable.renounce_ownership,\n)\n\n\n################################################################\n#                           CONSTANTS                          #\n################################################################\n\nMAX_N_BROADCAST: constant(uint256) = 32\nGET_BLOCKHASH_SELECTOR: constant(Bytes[4]) = method_id(\"get_blockhash(uint256,bool)\")\nBROADCAST_REQUEST_MESSAGE: constant(Bytes[17]) = b\"broadcast_request\"\n\n\n################################################################\n#                            STORAGE                           #\n################################################################\n\nis_initialized: public(bool)\n\n# Read configuration\nis_read_enabled: public(bool)\nmainnet_eid: public(uint32)\nmainnet_block_view: public(address)\n\n# Block oracle\nblock_oracle: public(IBlockOracle)\n\n# Refund address\ndefault_lz_refund_address: public(address)\n\n# Struct for cached broadcast info\nstruct BroadcastTarget:\n    eid: uint32\n    fee: uint256\n\n# Cached broadcast targets\ncached_broadcast_targets: DynArray[BroadcastTarget, MAX_N_BROADCAST]\n\n\n################################################################\n#                            EVENTS                            #\n################################################################\n\nevent BlockHashBroadcast:\n    source_eid: uint32\n    block_number: uint256\n    block_hash: bytes32\n    targets: DynArray[BroadcastTarget, MAX_N_BROADCAST]\n\n\n################################################################\n#                          CONSTRUCTOR                         #\n################################################################\n\n@deploy\ndef __init__(_owner: address):\n    \"\"\"\n    @notice Empty constructor for deterministic deployment\n    \"\"\"\n    lz.__init__()\n    ownable.__init__()\n    ownable._transfer_ownership(_owner)\n\n\n@external\ndef initialize(\n    _endpoint: address,\n    _gas_limit: uint256,\n    _read_channel: uint32,\n    # Can optionally initialize with peers\n    _peer_eids: DynArray[uint32, lz.MAX_PEERS],\n    _peers: DynArray[address, lz.MAX_PEERS],\n    # Also can provide libs (must provide lib types: 1 for lzsend, 2 for lzreceive)\n    _channels: DynArray[uint32, lz.MAX_PEERS],\n    _libs: DynArray[address, lz.MAX_PEERS],\n    _lib_types: DynArray[uint16, lz.MAX_PEERS],\n):\n    \"\"\"\n    @notice Initialize contract with core settings\n    @dev Can only be called once, assumes caller is owner, sets as delegate\n    @param _endpoint LayerZero endpoint address\n    @param _gas_limit Default gas limit for cross-chain messages\n    @param _read_channel LZ Read channel ID\n    \"\"\"\n    ownable._check_owner()\n    assert not self.is_initialized, \"Already initialized\"\n    assert _endpoint != empty(address), \"Invalid endpoint\"\n\n    self.is_initialized = True\n    self.default_lz_refund_address = self\n\n    # Initialize LayerZero module\n    lz._initialize(_endpoint, _gas_limit, _read_channel, _peer_eids, _peers)\n\n    # Set owner as delegate\n    lz._set_delegate(msg.sender)\n\n    # Set libs if provided\n    assert len(_channels) == len(_libs), \"Libs-channels length mismatch\"\n    assert len(_libs) == len(_lib_types), \"Libs-types length mismatch\"\n    for i: uint256 in range(0, len(_channels), bound=lz.MAX_PEERS):\n        if _lib_types[i] == 1:\n            lz._set_send_lib(_channels[i], _libs[i])\n        elif _lib_types[i] == 2:\n            lz._set_receive_lib(_channels[i], _libs[i])\n        else:\n            raise (\"Invalid lib type\")\n\n\n################################################################\n#                      OWNER FUNCTIONS                         #\n################################################################\n\n@external\ndef set_peer(_srcEid: uint32, _peer: address):\n    \"\"\"\n    @notice Set trusted peer contract on another chain\n    @param _srcEid Target endpoint ID\n    @param _peer Contract address on target chain\n    \"\"\"\n\n    ownable._check_owner()\n    lz._set_peer(_srcEid, _peer)\n\n\n@external\ndef set_default_gas(_gas_limit: uint256):\n    \"\"\"\n    @notice Update default gas limit for messages\n    @param _gas_limit New gas limit\n    \"\"\"\n\n    ownable._check_owner()\n    lz._set_default_gas_limit(_gas_limit)\n\n\n@external\ndef set_lz_read_channel(_new_channel: uint32):\n    \"\"\"\n    @notice Set new read channel for read requests\n    @param _new_channel New read channel ID\n    \"\"\"\n\n    ownable._check_owner()\n    lz._set_lz_read_channel(_new_channel)\n\n\n@external\ndef set_lz_send_lib(_channel: uint32, _lib: address):\n    \"\"\"\n    @notice Set new send library for send requests\n    @param _channel Send channel ID\n    @param _lib New send library address\n    \"\"\"\n\n    ownable._check_owner()\n    lz._set_send_lib(_channel, _lib)\n\n\n@external\ndef set_lz_receive_lib(_channel: uint32, _lib: address):\n    \"\"\"\n    @notice Set new receive library for receive requests\n    @param _channel Receive channel ID\n    @param _lib New receive library address\n    \"\"\"\n\n    ownable._check_owner()\n    lz._set_receive_lib(_channel, _lib)\n\n\n@external\ndef set_lz_delegate(_delegate: address):\n    \"\"\"\n    @notice Set new delegate for LayerZero operations\n    @param _delegate New delegate address\n    \"\"\"\n\n    ownable._check_owner()\n    lz._set_delegate(_delegate)\n\n\n@external\ndef set_lz_uln_config(\n    _eid: uint32,\n    _oapp: address,\n    _lib: address,\n    _config_type: uint32,\n    _confirmations: uint64,\n    _required_dvns: DynArray[address, 10],\n    _optional_dvns: DynArray[address, 10],\n    _optional_dvn_threshold: uint8,\n):\n    \"\"\"\n    @notice Set new ULN configuration for cross-chain messages\n    @param _eid Endpoint ID\n    @param _oapp Originating application address\n    @param _lib Library address\n    @param _config_type Configuration type\n    @param _confirmations Number of confirmations required\n    @param _required_dvns List of required DVN addresses\n    @param _optional_dvns List of optional DVN addresses\n    @param _optional_dvn_threshold Optional DVN threshold\n    \"\"\"\n\n    ownable._check_owner()\n    lz._set_uln_config(\n        _eid,\n        _oapp,\n        _lib,\n        _config_type,\n        _confirmations,\n        _required_dvns,\n        _optional_dvns,\n        _optional_dvn_threshold,\n    )\n\n\n@external\ndef set_read_config(_is_enabled: bool, _mainnet_eid: uint32, _mainnet_view: address):\n    \"\"\"\n    @notice Configure read functionality\n    @param _is_enabled Whether this contract can initiate reads\n    @param _mainnet_eid Mainnet endpoint ID\n    @param _mainnet_view MainnetBlockView contract address\n    \"\"\"\n    ownable._check_owner()\n    self.is_read_enabled = _is_enabled\n    self.mainnet_eid = _mainnet_eid\n    self.mainnet_block_view = _mainnet_view\n\n\n@external\ndef set_block_oracle(_oracle: address):\n    \"\"\"\n    @notice Set the block oracle address\n    @param _oracle Block oracle address\n    \"\"\"\n    ownable._check_owner()\n    self.block_oracle = IBlockOracle(_oracle)\n\n\n@external\ndef set_default_lz_refund_address(_refund_address: address):\n    \"\"\"\n    @notice Set default refund address for LayerZero operations\n    @param _refund_address New refund address\n    \"\"\"\n    ownable._check_owner()\n    self.default_lz_refund_address = _refund_address\n\n\n@external\ndef withdraw_eth(_amount: uint256):\n    \"\"\"\n    @notice Withdraw ETH from contract\n    @param _amount Amount to withdraw\n    \"\"\"\n\n    ownable._check_owner()\n    assert self.balance >= _amount, \"Insufficient balance\"\n    send(msg.sender, _amount)\n\n\n################################################################\n#                     INTERNAL FUNCTIONS                       #\n################################################################\n\n@internal\ndef _commit_block(_block_number: uint256, _block_hash: bytes32):\n    \"\"\"\n    @notice Commit block hash to oracle\n    \"\"\"\n    assert self.block_oracle != empty(IBlockOracle), \"Oracle not configured\"\n    extcall self.block_oracle.commit_block(_block_number, _block_hash)\n\n\n@view\n@internal\ndef _prepare_read_request(_block_number: uint256) -> Bytes[lz.LZ_MESSAGE_SIZE_CAP]:\n    \"\"\"\n    @notice Prepare complete read request message for MainnetBlockView\n    @param _block_number Block number to request (0 for latest)\n    @return Prepared LayerZero message bytes\n    \"\"\"\n    # Build calldata\n    calldata: Bytes[lz.LZ_READ_CALLDATA_SIZE] = abi_encode(\n        _block_number, True, method_id=GET_BLOCKHASH_SELECTOR\n    )\n\n    # Prepare read message\n    return lz._prepare_read_message_bytes(\n        self.mainnet_eid, # _dst_eid\n        self.mainnet_block_view, # _target\n        calldata, # _calldata\n        False, # _isBlockNum, we use timestamp\n        convert(block.timestamp, uint64), # _blockNumOrTimestamp, we use latest timestamp\n        1, # _confirmations set to 1 because we read 'older' blocks that cant be affected by reorgs\n    )\n\n\n@internal\ndef _broadcast_block(\n    _block_number: uint256,\n    _block_hash: bytes32,\n    _broadcast_targets: DynArray[BroadcastTarget, MAX_N_BROADCAST],\n    _source_eid: uint32,\n):\n    \"\"\"\n    @notice Internal function to broadcast block hash to multiple chains\n    @param _block_number Block number to broadcast\n    @param _block_hash Block hash to broadcast\n    @param _broadcast_targets Array of targets with their fees\n    @param _source_eid Chain ID where the block hash originated from\n    \"\"\"\n    message: Bytes[lz.LZ_MESSAGE_SIZE_CAP] = abi_encode(_block_number, _block_hash)\n\n    for target: BroadcastTarget in _broadcast_targets:\n        # BroadcastTarget is a struct with .eid and .fee\n        target_address: address = lz.LZ_PEERS[target.eid]  # Use LZ_PEERS directly\n        if target_address == empty(address):\n            continue\n\n        lz._send_message(\n            target.eid,  # _dstEid\n            convert(target_address, bytes32),  # _receiver\n            message,  # _message\n            0,  # _gas_limit: Use default gas limit\n            0,  # _lz_receive_value: No value to attach to receive call\n            0,  # _data_size: Zero data size (not a read)\n            target.fee,  # _request_msg_value: Use cached fee as send message value\n            self,  # _refund_address: shouldn't refund executor\n            False,  # _perform_fee_check: No fee check\n        )\n\n    log BlockHashBroadcast(_source_eid, _block_number, _block_hash, _broadcast_targets)\n\n\n@internal\ndef _request_block_hash(\n    _target_eids: DynArray[uint32, MAX_N_BROADCAST],\n    _target_fees: DynArray[uint256, MAX_N_BROADCAST],\n    _block_number: uint256,\n    _gas_limit: uint256,\n    _request_msg_value: uint256,\n    _refund_address: address,\n):\n    \"\"\"\n    @notice Internal function to request block hash from mainnet and broadcast to specified targets\n    \"\"\"\n    assert self.is_read_enabled, \"Read not enabled - call set_read_config\"\n    assert self.mainnet_block_view != empty(address), \"Mainnet view not set - call set_read_config\"\n    assert len(_target_eids) == len(_target_fees), \"Length mismatch\"\n\n    # Cache target EIDs and fees for lzReceive\n    cached_targets: DynArray[BroadcastTarget, MAX_N_BROADCAST] = []\n    sum_target_fees: uint256 = 0\n    for i: uint256 in range(0, len(_target_eids), bound=MAX_N_BROADCAST):\n        cached_targets.append(BroadcastTarget(eid=_target_eids[i], fee=_target_fees[i]))\n        sum_target_fees += _target_fees[i]\n    self.cached_broadcast_targets = cached_targets\n\n    message: Bytes[lz.LZ_MESSAGE_SIZE_CAP] = self._prepare_read_request(_block_number)\n\n    # Send to read channel with enough value to cover broadcasts\n    lz._send_message(\n        lz.LZ_READ_CHANNEL,  # _dstEid\n        convert(self, bytes32),  # _receiver\n        message,  # _message\n        _gas_limit,  # _gas_limit: Use default gas limit\n        sum_target_fees,  # _lz_receive_value: Will be available in lzReceive (and pay for broadcasts)\n        64,  # _data_size: Expected read size (uint256: block number, bytes32: block hash)\n        _request_msg_value,  # _request_msg_value: Use provided value\n        _refund_address,  # _refund_address: Refund unspent fees to specified address\n        False,  # _perform_fee_check: No fee check\n    )\n\n\n################################################################\n#                     EXTERNAL FUNCTIONS                       #\n################################################################\n\n@external\n@payable\ndef __default__():\n    \"\"\"\n    @notice Default function to receive ETH\n    @dev This is needed to receive refunds from LayerZero\n    \"\"\"\n    pass\n\n\n@view\n@external\ndef quote_read_fee(\n    _block_number: uint256 = 0,\n    _gas_limit: uint256 = 0,\n    _value: uint256 = 0,\n    _data_size: uint32 = 64,\n) -> uint256:\n    \"\"\"\n    @notice Quote fee for reading block hash from mainnet\n    @param _block_number Optional block number (0 means latest)\n    @param _gas_limit Optional gas limit override\n    @return Fee in native tokens required for the read operation\n    \"\"\"\n    assert self.is_read_enabled, \"Read not enabled - call set_read_config\"\n    assert self.mainnet_block_view != empty(address), \"Mainnet view not set - call set_read_config\"\n\n    message: Bytes[lz.LZ_MESSAGE_SIZE_CAP] = self._prepare_read_request(_block_number)\n\n    return lz._quote_lz_fee(\n        lz.LZ_READ_CHANNEL,\n        empty(address),\n        message,\n        _gas_limit,\n        _value,\n        _data_size,  # Expected response size\n    )\n\n\n@view\n@external\ndef quote_broadcast_fees(\n    _target_eids: DynArray[uint32, MAX_N_BROADCAST], _gas_limit: uint256 = 0\n) -> DynArray[uint256, MAX_N_BROADCAST]:\n    \"\"\"\n    @notice Quote fees for broadcasting block hash to specified targets\n    @param _target_eids List of chain IDs to broadcast to\n    @param _gas_limit Optional gas limit override\n    @return Array of fees per target chain (0 if target not configured)\n    \"\"\"\n    # Prepare dummy broadcast message (uint256 number, bytes32 hash)\n    message: Bytes[lz.LZ_MESSAGE_SIZE_CAP] = abi_encode(empty(uint256), empty(bytes32))\n\n    # Get fees per chain\n    fees: DynArray[uint256, MAX_N_BROADCAST] = []\n\n    for eid: uint32 in _target_eids:\n        target: address = lz.LZ_PEERS[eid]  # Use LZ_PEERS directly\n        if target == empty(address):\n            fees.append(0)\n            continue\n\n        fee: uint256 = lz._quote_lz_fee(eid, target, message, _gas_limit)\n        fees.append(fee)\n\n    return fees\n\n\n@payable\n@external\ndef request_block_hash(\n    _target_eids: DynArray[uint32, MAX_N_BROADCAST],\n    _target_fees: DynArray[uint256, MAX_N_BROADCAST],  # Add fees array parameter\n    _block_number: uint256 = 0,\n    _gas_limit: uint256 = 0,\n):\n    \"\"\"\n    @notice Request block hash from mainnet and broadcast to specified targets\n    @param _target_eids List of chain IDs to broadcast to\n    @param _target_fees List of fees per chain (must match _target_eids length)\n    @param _block_number Optional block number (0 means latest)\n    @param _gas_limit Optional gas limit override\n    @dev User must ensure msg.value is sufficient:\n         - must cover read fee (quote_read_fee)\n         - must cover broadcast fees (quote_broadcast_fees)\n    \"\"\"\n    self._request_block_hash(\n        _target_eids,\n        _target_fees,\n        _block_number,\n        _gas_limit,\n        msg.value,  # Use full msg.value\n        msg.sender,  # Refund to sender\n    )\n\n\n@payable\n@external\ndef broadcast_latest_block(\n    _target_eids: DynArray[uint32, MAX_N_BROADCAST],\n    _target_fees: DynArray[uint256, MAX_N_BROADCAST],\n):\n    \"\"\"\n    @notice Broadcast latest confirmed block hash to specified chains\n    @param _target_eids List of chain IDs to broadcast to\n    @param _target_fees List of fees per chain (must match _target_eids length)\n    \"\"\"\n    assert self.is_read_enabled, \"Can only broadcast from read-enabled chains\"\n    assert self.block_oracle != empty(IBlockOracle), \"Oracle not configured\"\n    assert len(_target_eids) == len(_target_fees), \"Length mismatch\"\n\n    # Get latest block from oracle\n    block_number: uint256 = staticcall self.block_oracle.last_confirmed_block_number()\n    block_hash: bytes32 = staticcall self.block_oracle.block_hash(block_number)\n    assert block_hash != empty(bytes32), \"No confirmed blocks\"\n\n    # Prepare broadcast targets\n    broadcast_targets: DynArray[BroadcastTarget, MAX_N_BROADCAST] = []\n    for i: uint256 in range(0, len(_target_eids), bound=MAX_N_BROADCAST):\n        broadcast_targets.append(BroadcastTarget(eid=_target_eids[i], fee=_target_fees[i]))\n\n    self._broadcast_block(block_number, block_hash, broadcast_targets, lz.EID)\n\n\n@payable\n@external\ndef request_remote_read(\n    _remote_eid: uint32,\n    _read_fee: uint256,\n    _broadcast_fee: uint256,\n    _request_gas_limit: uint256 = 0,\n):\n    \"\"\"\n    @notice Request a chain to perform an lzread operation and broadcast the result back to us\n    @param _remote_eid Chain ID to request the read from\n    @param _read_fee Fee to cover the lzread operation on target chain\n    @param _broadcast_fee Fee to cover broadcasting the result back to us\n    @dev msg.value must cover both:\n         - fee to send request to target chain\n         - _read_fee + _broadcast_fee which will be used by target chain\n    \"\"\"\n    # Prepare broadcast request message (magic bytes + fee)\n    message: Bytes[lz.LZ_MESSAGE_SIZE_CAP] = concat(\n        BROADCAST_REQUEST_MESSAGE,  # 17 bytes\n        convert(_broadcast_fee, bytes32),  # 32 bytes\n    )\n\n    # Send message to target chain\n    lz._send_message(\n        _remote_eid,  # _dstEid\n        convert(\n            lz.LZ_PEERS[_remote_eid], bytes32\n        ),  # _receiver - can only be configured peer (self)\n        message,  # _message\n        _request_gas_limit,  # _gas_limit for read request\n        _read_fee + _broadcast_fee,  # _lz_receive_value: must cover both read and broadcast\n        0,  # _data_size: Zero data size (not a read)\n        msg.value,  # _request_msg_value: Use full msg.value\n        msg.sender,  # _refund_address: Refund to sender\n        True,  # _perform_fee_check: Check fees\n    )\n\n\n@payable\n@external\ndef lzReceive(\n    _origin: lz.Origin,\n    _guid: bytes32,\n    _message: Bytes[lz.LZ_MESSAGE_SIZE_CAP],\n    _executor: address,\n    _extraData: Bytes[64],\n) -> bool:\n    \"\"\"\n    @notice Handle messages: read responses, broadcast requests, and regular messages\n    @dev Three types of messages:\n         1. Read responses (from read channel)\n         2. Broadcast requests (magic bytes + fee)\n         3. Regular messages (block hash broadcasts)\n    @dev Broadcast request format:\n         - First 17 bytes: BROADCAST_REQUEST_MESSAGE\n         - Next 32 bytes: uint256 fee for return broadcast\n    \"\"\"\n    # Verify message source\n    assert lz._lz_receive(_origin, _guid, _message, _executor, _extraData)\n\n    if lz._is_read_response(_origin):\n        # Only handle read response if read is enabled\n        assert self.is_read_enabled, \"Read not enabled\"\n\n        # Decode block hash and number from response\n        block_number: uint256 = 0\n        block_hash: bytes32 = empty(bytes32)\n        block_number, block_hash = abi_decode(_message, (uint256, bytes32))\n        if block_hash == empty(bytes32):\n            return True  # Invalid response\n\n        self._commit_block(block_number, block_hash)\n\n        # Get cached targets and broadcast if we have any\n        broadcast_targets: DynArray[\n            BroadcastTarget, MAX_N_BROADCAST\n        ] = self.cached_broadcast_targets\n        if len(broadcast_targets) > 0:\n            # Perform broadcast and clear cache\n            self._broadcast_block(block_number, block_hash, broadcast_targets, _origin.srcEid)\n            self.cached_broadcast_targets = empty(DynArray[BroadcastTarget, MAX_N_BROADCAST])\n    elif slice(_message, 0, 17) == BROADCAST_REQUEST_MESSAGE:  # 17 + 32 bytes\n        # Handle broadcast request - decode fee and trigger read\n        broadcast_fee: uint256 = abi_decode(slice(_message, 17, 32), (uint256))\n\n        # msg.value must cover both read and broadcast\n        assert broadcast_fee <= msg.value, \"Insufficient message value\"\n\n        self._request_block_hash(\n            [_origin.srcEid],  # Single target - the requesting chain\n            [broadcast_fee],  # Use the decoded fee for broadcast\n            0,  # Latest block\n            2 * lz.default_gas_limit,  # Default gas limit x2 (read + broadcast)\n            msg.value,  # covers read and broadcast\n            self,  # Keep refunds in contract [not set at current deploy, TODO set default_lz_refund_address]\n        )\n\n    else:\n        # Regular message - decode and commit block hash\n        block_number: uint256 = 0\n        block_hash: bytes32 = empty(bytes32)\n        block_number, block_hash = abi_decode(_message, (uint256, bytes32))\n        self._commit_block(block_number, block_hash)\n\n    return True\n", "sha256sum": "c779d2434cc99f11dca86f4b6dace1b19056b946252cd00088789535bf28d9e7"}}, "settings": {"outputSelection": {"contracts/messengers/LZBlockRelay.vy": ["*"]}, "search_paths": [".venv/lib/python3.12/site-packages", "."]}, "compiler_version": "v0.4.0+commit.e9db8d9", "integrity": "412b7e8e0cfc53d965d346e2b41984d24ad80455f9e8f5005c146bfe76f351b0"}
