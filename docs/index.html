<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Blockhash Oracle Status - Minimal</title>
    <style>
        body {
            font-family: monospace;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #0a0a0a;
            color: #fff;
        }
        h1 { font-size: 2em; margin-bottom: 0.5em; }
        h2 { font-size: 1.5em; margin-top: 1em; }
        a { color: #6366f1; text-decoration: none; }
        a:hover { text-decoration: underline; }
        table { width: 100%; border-collapse: collapse; margin: 1em 0; }
        th, td { text-align: left; padding: 8px; border: 1px solid #333; }
        th { background: #1a1a1a; }
        td { background: #0a0a0a; }
        .mainnet { background: #1a1a1a; padding: 1em; margin: 1em 0; border: 1px solid #333; border-radius: 8px; }
        .number { font-size: 2em; font-weight: bold; color: #6366f1; }
        .error { color: #ef4444; }
        .outdated { color: #f59e0b; }
        .loading { color: #888; }
        button {
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            background: #6366f1;
            color: white;
            border: none;
            border-radius: 6px;
            margin: 2px;
        }
        button:hover { background: #5558e3; }
        button:disabled {
            background: #444;
            cursor: not-allowed;
            opacity: 0.6;
        }
        /* Tiny buttons */
        .tiny-btn {
            font-size: 11px;
            padding: 2px 6px;
            margin: 1px;
        }
        small { color: #888; }
        hr { border: 1px solid #333; }
        .notice {
            background: #f59e0b20;
            border: 1px solid #f59e0b;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>Blockhash Oracle Status</h1>
    <p>Minimal dashboard - GitHub Pages version.</p>

    <div>
        <button disabled title="Wallet connection is disabled on GitHub Pages">Connect Wallet</button>
        <button onclick="location.reload()">Refresh</button>
    </div>

    <div class="notice">
        <p>⚠️ This is a read-only GitHub Pages version. Transaction features are disabled.</p>
        <p>For full functionality, clone the repository and run locally.</p>
    </div>

    <div class="mainnet">
        <h2>Ethereum Mainnet</h2>
        <div class="number" id="mainnet-block">Loading...</div>
        <div id="mainnet-address"></div>
    </div>

    <h2>Oracle Status</h2>
    <table id="oracle-table">
        <thead>
            <tr>
                <th>Chain</th>
                <th>Read</th>
                <th>Block</th>
                <th>Header</th>
                <th>Contracts</th>
                <th style="width: 140px;">Actions</th>
            </tr>
        </thead>
        <tbody id="oracle-tbody">
            <tr><td colspan="6">Loading...</td></tr>
        </tbody>
    </table>

    <hr>
    <p><small>Minimal HTML dashboard. Transaction features require local hosting.</small></p>

    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script>
        // GitHub Pages URLs
        const GITHUB_RAW_BASE = 'https://raw.githubusercontent.com/curvefi/blockhash-oracle/main';
        const DEPLOYMENT_URL = `${GITHUB_RAW_BASE}/scripts/deployment/deployment_state.json`;
        const CHAINS_URL = `${GITHUB_RAW_BASE}/scripts/chain-parse/chains.json`;

        // Explorer URLs
        const EXPLORERS = {
            ethereum: 'https://etherscan.io/address/',
            arbitrum: 'https://arbiscan.io/address/',
            optimism: 'https://optimistic.etherscan.io/address/',
            polygon: 'https://polygonscan.com/address/',
            avalanche: 'https://snowscan.xyz/address/',
            bsc: 'https://bscscan.com/address/',
            fantom: 'https://ftmscan.com/address/',
            base: 'https://basescan.org/address/',
            gnosis: 'https://gnosisscan.io/address/',
            celo: 'https://celoscan.io/address/',
            moonbeam: 'https://moonscan.io/address/',
            mantle: 'https://explorer.mantle.xyz/address/',
            fraxtal: 'https://fraxscan.com/address/',
            taiko: 'https://taikoscan.io/address/',
            sonic: 'https://sonicscan.org/address/',
            xlayer: 'https://www.oklink.com/x-layer/address/',
            kava: 'https://kavascan.com/address/',
            aurora: 'https://explorer.aurora.dev/address/',
            xdc: 'https://xdcscan.com/address/',
            tac: 'https://explorer.tac.build/address/',
            hyperliquid: 'https://purrsec.com/explorer/address/',
            ink: 'https://explorer.inkonchain.com/address/',
            plume_phoenix: 'https://explorer.plumenetwork.xyz/address/',
            mp1: 'https://cornscan.io/address/'
        };

        // ABIs
        const ORACLE_ABI = [
            "function last_confirmed_block_number() view returns (uint256)",
            "function last_confirmed_header() view returns (bytes32, bytes32, bytes32, bytes32, uint256, uint256)"
        ];

        const RELAY_ABI = [
            "function read_enabled() view returns (bool)"
        ];

        let mainnetBlock = 0;

        // Format address
        function formatAddress(addr) {
            return `${addr.slice(0, 12)}...${addr.slice(-5)}`;
        }

        // Get explorer link
        function explorerLink(chain, addr) {
            const base = EXPLORERS[chain] || 'https://blockscan.com/address/';
            return `<a href="${base}${addr}" target="_blank">${formatAddress(addr)}</a>`;
        }

        // Calculate time ago
        function timeAgo(blockNum) {
            if (!mainnetBlock || blockNum <= 0) return '';
            const diff = mainnetBlock - blockNum;
            const seconds = diff * 12;
            if (seconds < 60) return `${seconds}s ago`;
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
            if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
            const days = Math.floor(seconds / 86400);
            const hours = Math.floor((seconds % 86400) / 3600);
            return `${days}d${hours}h ago`;
        }

        // Sort table rows
        function sortTable() {
            const tbody = document.getElementById('oracle-tbody');
            const rows = Array.from(tbody.getElementsByTagName('tr'));

            rows.sort((a, b) => {
                const aName = a.cells[0].textContent;
                const bName = b.cells[0].textContent;
                const aData = window.chainData[aName];
                const bData = window.chainData[bName];

                if (!aData || !bData) return 0;

                // First sort by read-enabled (true first)
                if (aData.readEnabled !== bData.readEnabled) {
                    return aData.readEnabled ? -1 : 1;
                }

                // Then by block freshness (higher block number first)
                if (aData.lastBlock !== bData.lastBlock) {
                    return bData.lastBlock - aData.lastBlock;
                }

                // Finally alphabetically
                return aName.localeCompare(bName);
            });

            // Re-append sorted rows
            rows.forEach(row => tbody.appendChild(row));
        }

        // Load everything
        async function loadData() {
            try {
                // Fetch config files
                const [depRes, chainsRes] = await Promise.all([
                    fetch(DEPLOYMENT_URL),
                    fetch(CHAINS_URL)
                ]);

                const deployments = (await depRes.json()).deployments.mainnets || {};
                const chains = (await chainsRes.json()).mainnets || {};

                // Get mainnet block
                if (chains.ethereum?.public) {
                    try {
                        const provider = new ethers.providers.JsonRpcProvider(chains.ethereum.public);
                        mainnetBlock = await provider.getBlockNumber();
                        document.getElementById('mainnet-block').textContent = mainnetBlock.toLocaleString();
                    } catch (e) {
                        document.getElementById('mainnet-block').textContent = 'Error';
                    }
                }

                // Show mainnet address
                if (deployments.ethereum?.MainnetBlockView) {
                    document.getElementById('mainnet-address').innerHTML =
                        `View: ${explorerLink('ethereum', deployments.ethereum.MainnetBlockView)}`;
                }

                // Build table rows
                const tbody = document.getElementById('oracle-tbody');
                tbody.innerHTML = '';

                // Initialize chain data for sorting
                window.chainData = {};

                // Process each chain
                const chainList = [];
                for (const [chainName, contracts] of Object.entries(deployments)) {
                    if (chainName === 'ethereum' || !contracts.BlockOracle) continue;
                    chainList.push({ chainName, contracts });
                }

                // Initial alphabetical sort
                chainList.sort((a, b) => a.chainName.localeCompare(b.chainName));

                // Create rows
                for (const { chainName, contracts } of chainList) {
                    const row = document.createElement('tr');
                    const chain = chains[chainName] || {};

                    // Chain name
                    const chainCell = document.createElement('td');
                    chainCell.textContent = chainName;
                    row.appendChild(chainCell);

                    // Read enabled status
                    const readCell = document.createElement('td');
                    readCell.id = `read-${chainName}`;
                    readCell.innerHTML = '<span class="loading">...</span>';
                    row.appendChild(readCell);

                    // Block number
                    const blockCell = document.createElement('td');
                    blockCell.innerHTML = '<span class="loading">...</span>';
                    row.appendChild(blockCell);

                    // Header block
                    const headerCell = document.createElement('td');
                    headerCell.innerHTML = '<span class="loading">...</span>';
                    row.appendChild(headerCell);

                    // Contract links
                    const contractCell = document.createElement('td');
                    const links = [];
                    if (contracts.BlockOracle) links.push(explorerLink(chainName, contracts.BlockOracle));
                    if (contracts.LZBlockRelay) links.push(explorerLink(chainName, contracts.LZBlockRelay));
                    if (contracts.HeaderVerifier) links.push(explorerLink(chainName, contracts.HeaderVerifier));
                    contractCell.innerHTML = links.join(' | ');
                    row.appendChild(contractCell);

                    // Actions (always show buttons, but disabled with tooltip)
                    const actionCell = document.createElement('td');
                    actionCell.style.textAlign = 'right';
                    actionCell.setAttribute('data-chain', chainName);

                    // Always create header button
                    const headerBtn = document.createElement('button');
                    headerBtn.className = 'tiny-btn';
                    headerBtn.textContent = 'Header';
                    headerBtn.disabled = true;
                    headerBtn.title = 'Submit header is disabled on GitHub Pages';
                    actionCell.appendChild(headerBtn);

                    row.appendChild(actionCell);

                    tbody.appendChild(row);

                    // Initialize chain data
                    window.chainData[chainName] = {
                        readEnabled: false,
                        lastBlock: 0,
                        loaded: false
                    };

                    // Fetch chain data async
                    if (chain.public) {
                        fetchChainData(chainName, chain.public, contracts, blockCell, headerCell, readCell);
                    } else {
                        readCell.innerHTML = '<span class="error">-</span>';
                        blockCell.innerHTML = '<span class="error">No RPC</span>';
                        headerCell.innerHTML = '<span class="error">No RPC</span>';
                    }
                }
            } catch (error) {
                console.error('Failed to load:', error);
                document.getElementById('oracle-tbody').innerHTML =
                    '<tr><td colspan="6" class="error">Failed to load data</td></tr>';
            }
        }

        // Fetch data for a single chain
        async function fetchChainData(chainName, rpc, contracts, blockCell, headerCell, readCell) {
            try {
                const provider = new ethers.providers.JsonRpcProvider(rpc);
                const oracle = new ethers.Contract(contracts.BlockOracle, ORACLE_ABI, provider);

                // Get last block
                const lastBlockNum = await oracle.last_confirmed_block_number();
                const lastBlock = lastBlockNum.toNumber();
                blockCell.innerHTML = `${lastBlock.toLocaleString()} <small>(${timeAgo(lastBlock)})</small>`;

                // Get last header
                let lastHeaderBlock = 0;
                let readEnabled = false;

                try {
                    const lastHeader = await oracle.last_confirmed_header();
                    if (lastHeader && lastHeader[4]) {
                        lastHeaderBlock = lastHeader[4].toNumber();
                    }
                } catch (e) {
                    // No header
                }

                // Check if read enabled
                if (contracts.LZBlockRelay) {
                    try {
                        const relay = new ethers.Contract(contracts.LZBlockRelay, RELAY_ABI, provider);
                        readEnabled = await relay.read_enabled();
                    } catch {}
                }

                if (lastHeaderBlock > 0) {
                    const isOutdated = lastHeaderBlock < lastBlock;
                    headerCell.innerHTML =
                        `<span class="${isOutdated ? 'outdated' : ''}">${lastHeaderBlock.toLocaleString()}</span> ` +
                        `<small>(${timeAgo(lastHeaderBlock)})</small>`;
                } else {
                    headerCell.innerHTML = '<span class="error">None</span>';
                }

                // Update read enabled cell
                if (readCell) {
                    readCell.innerHTML = readEnabled ? '✓' : '-';
                    readCell.style.color = readEnabled ? '#10b981' : '#666';
                    readCell.style.textAlign = 'center';
                }

                // Store chain data for sorting
                window.chainData[chainName] = {
                    readEnabled: readEnabled,
                    lastBlock: lastBlock,
                    loaded: true
                };

                // Re-sort table when data loads
                sortTable();

                // Update button states
                const actionCell = document.querySelector(`td[data-chain="${chainName}"]`);
                if (actionCell) {
                    // Add broadcast button if read enabled
                    if (readEnabled && contracts.LZBlockRelay && !document.getElementById(`broadcast-${chainName}`)) {
                        const broadcastBtn = document.createElement('button');
                        broadcastBtn.className = 'tiny-btn';
                        broadcastBtn.id = 'broadcast-' + chainName;
                        broadcastBtn.textContent = 'Broadcast';
                        broadcastBtn.disabled = true;
                        broadcastBtn.title = 'Broadcast is disabled on GitHub Pages';
                        // Insert before header button
                        actionCell.insertBefore(broadcastBtn, actionCell.firstChild);
                    }
                }
            } catch (error) {
                blockCell.innerHTML = '<span class="error">Error</span>';
                headerCell.innerHTML = '<span class="error">Error</span>';
            }
        }

        // Load on start
        loadData();
    </script>
</body>
</html>
